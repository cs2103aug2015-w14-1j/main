# A0125471L
###### src/notify/DateRange.java
``` java

/**
 * Author: Chua Si Hao
 * Matric No: A0125471L
 * For CS2103T - Notify
 */

package notify;

import java.util.Calendar;

import notify.logic.parser.DateTimeParser;

public class DateRange {
	
	// These are the variables required to store the individual start and end range
	private Calendar startDate;
	private Calendar startTime;
	private Calendar endDate;
	private Calendar endTime;
	
	// These are the variables required to store the individual start and end range
	private static final String ERROR_DATE_RANGE = "You have entered an invalid date range.";
	
	public DateRange() { 
		
		this.startDate = null;
		this.startTime = null;
		this.endDate = null;
		this.endTime = null;
		
	}
	
	public DateRange(Calendar startDate, Calendar startTime, Calendar endDate, Calendar endTime) {
		
		this.startDate = startDate;
		this.endDate = endDate;
		this.startTime = startTime;
		this.endTime = endTime;
	
	}
	
	public DateRange(String startDate, String startTime, String endDate, String endTime) {
	
		setStartDate(startDate);
		setEndDate(endDate);
		setStartTime(startTime);
		setEndTime(endTime);
	
	}
	
	/**
	 * Returns the start date indicated in the DateRange
	 * 
	 *  @return Calendar start date is instantiated with default time values in the date range
	 *  			only the date variables are useful. Returns null if end date do not exists
	 * 
	 */
	public Calendar getStartDate() { 
	
		return this.startDate;
	
	}
	
	/**
	 * Returns the start time indicated in the DateRange
	 * 
	 *  @return Calendar start time is instantiated with default date values in the date range
	 *  			only the time variables are useful. Returns null if end time do not exists
	 * 
	 */
	public Calendar getStartTime() {
		
		return this.startTime;
	
	}
	
	/**
	 * Returns the end date indicated in the DateRange
	 * 
	 *  @return Calendar end date is instantiated with default time values in the date range
	 *  			only the date variables are useful. Returns null if end date do not exists
	 * 
	 */
	public Calendar getEndDate() { 
		
		return this.endDate;
	
	}
	
	/**
	 * Returns the end time indicated in the DateRange
	 * 
	 *  @return Calendar end time is instantiated with default date values in the date range
	 *  			only the time variables are useful. Returns null if end time do not exists
	 * 
	 */
	public Calendar getEndTime() { 
		
		return this.endTime;
	
	}
	
	/**
	 * Sets the start date to be stored in the DateRange
	 * 
	 *  @param startDate is processed into a Calendar with the date values instantiated
	 *  			the time variables are instantiated to default
	 * 
	 */
	public void setStartDate(String startDate) {
		
		if(startDate != null) {
	
			startDate = startDate.trim();
			this.startDate = DateTimeParser.parseDate(startDate);
		
		}
	
	}
	
	/**
	 * Sets the start time to be stored in the DateRange
	 * 
	 *  @param startTime is processed into a Calendar with the time values instantiated
	 *  			the date variables are instantiated to default
	 * 
	 */
	public void setStartTime(String startTime) {
	
		if(startTime != null) {
	
			startTime = startTime.trim();
			this.startTime = DateTimeParser.parseTime(startTime);
			
			if(isSameDay() == true) { 
				
				if(this.startTime.after(this.endTime) || this.startTime.equals(this.endTime)) {
					
					throw new IllegalArgumentException(ERROR_DATE_RANGE);
					
				}
			
			}
		
		}
	
	}
	
	/**
	 * Sets the end date to be stored in the DateRange
	 * 
	 *  @param endDate is processed into a Calendar with the date values instantiated
	 *  			the time variables are instantiated to default
	 * 
	 */
	public void setEndDate(String endDate) {
		
		if(endDate != null) {
	
			endDate = endDate.trim();
			this.endDate = DateTimeParser.parseDate(endDate.trim());
			
			if(isSameDay() == true) { 
			
				if(this.endDate.before(this.startDate)) {
				
					throw new IllegalArgumentException(ERROR_DATE_RANGE);
				
				}
			
			}
		
		}
	
	}
	

	/**
	 * Sets the end time to be stored in the DateRange
	 * 
	 *  @param endTime is processed into a Calendar with the time values instantiated
	 *  			the date variables are instantiated to default
	 * 
	 */
	public void setEndTime(String endTime) {
	
		if(endTime != null) {
			
			endTime = endTime.trim();
			this.endTime = DateTimeParser.parseTime(endTime);
			
			if(isSameDay() == true) { 
				
				if(this.endTime.before(this.startTime)) {
			
					throw new IllegalArgumentException(ERROR_DATE_RANGE);
				
				}
			
			}
				
		}
	
	}
	
	/**
	 * Returns if the start and end dates are the same
	 * 
	 *  @param true if both days have the same date or either date is null
	 * 
	 */
	public boolean isSameDay() {
	
		boolean isSameDay = true;
		
		if(this.getStartDate() != null && this.getEndDate() != null) {
			
			if(this.getStartDate().get(Calendar.DATE) != this.getEndDate().get(Calendar.DATE)) { 
	
				isSameDay = false; 
			
			}
			
			if(this.getStartDate().get(Calendar.MONTH) != this.getEndDate().get(Calendar.MONTH)) { 
			
				isSameDay = false; 
			
			}
			
			if(this.getStartDate().get(Calendar.YEAR) != this.getEndDate().get(Calendar.YEAR)) { 
			
				isSameDay = false; 
			
			}
			
		}
			
		return isSameDay;

	}
	
	public String toString() {
	
		String output = "";
		
		if(startDate != null) { 
			output += "start: " + startDate.get(Calendar.DATE) + "-" + startDate.get(Calendar.MONTH) + "-" + startDate.get(Calendar.YEAR);
			if(startTime != null) { output += " " + startTime.get(Calendar.HOUR_OF_DAY) + ":" + startTime.get(Calendar.MINUTE); }
		}
		
		if(endDate != null) { 
			output += " to " + endDate.get(Calendar.DATE) + "-" + endDate.get(Calendar.MONTH) + "-" + endDate.get(Calendar.YEAR);
			if(endTime != null) { output += " " + endTime.get(Calendar.HOUR_OF_DAY) + ":" + endTime.get(Calendar.MINUTE); }
		}
		
		return output;
	}
	
}
```
###### src/notify/logic/command/Action.java
``` java

/**
 * Author: Chua Si Hao
 * Matric No: A0125471L
 * For CS2103T - Notify
 */

package notify.logic.command;

/**
 * The Action enumeration is used a list of command that is 
 * recognized by the system.
 */
public enum Action {
	
	ADD		    (true, true),
	BACK 		(false, false),
	DELETE 		(true, true),
	EDIT 		(true, true),
	SEARCH 		(false, false),
	MARK 		(true, true), 	
	DISPLAY 	(false, false),	
	UNDO 		(false, true), 
	SET 		(true, true),
	EXIT		(false, false),
	INVALID 	(false, false),
	HELP		(false, false);

	
	// These are the variables required to store states for each action
	public boolean isReversible;
	public boolean isPersistent;
	
	private Action(boolean isReversible, boolean isPersistent) {
		
		this.isReversible = isReversible;
		this.isPersistent = isPersistent;
	
	}
	
	/**
	 * Returns true if the selected command action can be reversed.
	 * 
	 * @return	true if the selected command action can be reversed
	 * 
	 */
	public boolean isReversible() {
	
		return this.isReversible;
	
	}
	
	/**
	 * Returns true if the selected command requires data to be stored.
	 * 
	 * @return	true if the selected command requires data to be stored
	 * 
	 */
	public boolean isPersistent() {
	
		return this.isPersistent;
	
	}
}
```
###### src/notify/logic/command/Command.java
``` java

/**
 * Author: Chua Si Hao
 * Matric No: A0125471L
 * For CS2103T - Notify
 */

package notify.logic.command;

/**
 * The Command abstraction is used as the basis for commands
 * supported by the system. 
 */
public abstract class Command {

	// Stores the selected action that the command is classified under
	private Action commandAction;
	
	public Command(Action commandAction) {
		
		this.commandAction = commandAction;
	
	}
	
	/**
	 * Commands have to implement their corresponding execute method
	 * The execute method should contain the logic to retrieve 
	 * and handle the indicated command 
	 */
	public abstract Result execute();
	
	/**
	 * Returns the type of persistence of the commandAction
	 * 
	 * @return	true if the commandAction indicated require records
	 * 				in storage to be updated
	 * 
	 */
	public boolean isPersistable() {
		
		return this.commandAction.isPersistent();
	
	}
}
```
###### src/notify/logic/command/Result.java
``` java

/**
 * Author: Chua Si Hao
 * Matric No: A0125471L
 * For CS2103T - Notify
 */

package notify.logic.command;

import java.util.ArrayList;

import notify.Task;

/**
 * The Result class stores the retrieve results to be used by 
 * Command class and Logic class
 */
public class Result {

	// These are variables used for quick access and default values required
	private static final int FIRST_RESULT_INDEX = 0;
	private static final boolean DEFAULT_IS_SUCCESS = true;

	// These are variables used to indicate the status of the results
	private Action actionPerformed;
	private ArrayList<Task> results;
	private boolean isSuccess;

	public Result(Action actionPerformed, ArrayList<Task> results) {
		
		this(actionPerformed, results, DEFAULT_IS_SUCCESS);
	
	}

	public Result(Action actionPerformed, ArrayList<Task> results, boolean isSuccess) {
		
		this.actionPerformed = actionPerformed;
		this.results = results;
		this.isSuccess = isSuccess;
	
	}

	/**
	 * Returns the Action type that is requested for
	 */
	public Action getActionPerformed() {
		
		return actionPerformed;
	
	}

	/**
	 * Returns the first item on the results list for quick access
	 * 
	 * @return Task containing the relevant results stored in within
	 * 			if the results list is empty, null is returned
	 * 
	 */
	public Task getFirstResult() {

		if (results.isEmpty()) {
			
			return null;
		
		}

		return results.get(FIRST_RESULT_INDEX);
	
	}

	/**
	 * Returns the list of results retrieved
	 */
	public ArrayList<Task> getResults() {
		
		return results;
	
	}

	/**
	 * Returns the state of execution of the action performed
	 * 
	 * @return	true if the execution is successful
	 * 
	 */
	public boolean isSuccess() {
		
		return isSuccess;
	
	}
}
```
###### src/notify/logic/command/ReversibleCommand.java
``` java

/**
 * Author: Chua Si Hao
 * Matric No: A0125471L
 * For CS2103T - Notify
 */

package notify.logic.command;

import java.util.Stack;

/**
 * The ReversibleCommand abstraction is used as the basis for commands
 * that provides the ability to have Action reversed after execution
 */
public abstract class ReversibleCommand extends Command {

	// Stores a list of actions that the user have entered
	private Stack<ReversibleCommand> historyStack;
	
	public ReversibleCommand(Action commandAction, Stack<ReversibleCommand> historyStack) {
	
		super(commandAction);
		this.historyStack = historyStack;
	
	}
	
	/**
	 * Pushes the current Command into the stack to prepare for undo
	 * Classes that are reversible should call this method once execute function is called
	 */
	protected void pushToStack() {
	
		historyStack.push(this);
	
	}
	
	/**
	 * Returns the command from the top of the stack
	 * This command is the immediate command that will be reverted
	 */
	protected ReversibleCommand retrieveLast() {
	
		return historyStack.pop();
	
	}
	
	/**
	 * Commands have to implement their corresponding undo method
	 * The undo method should contain the logic to revert the requested action
	 */
	public abstract Result undo();

}
```
###### src/notify/logic/logger/LogType.java
``` java

/**
 * Author: Chua Si Hao
 * Matric No: A0125471L
 * For CS2103T - Notify
 */

package notify.logic.logger;

/**
 * This LogType enumeration indicates the log types the user can log with
 */
public enum LogType { 
	
	DEBUG, ERROR, INFO, VERBOSE, WEIRD, WTF 
	
};
```
###### src/notify/logic/logger/Writer.java
``` java

/**
 * Author: Chua Si Hao
 * Matric No: A0125471L
 * For CS2103T - Notify
 */

package notify.logic.logger;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Calendar;

/**
 * This class is used to write log files to a directory   
 */
public class Writer {

	// These are the static variables required by the class
	public static final String STRING_LOG = "%1$s\t\t%2$s\t\t%3$s\t\t%4$s\n";
	public static final String ERROR_WRITE = "Unable to create log file. Logs will be written to console";
	
	// These are the required variables to determine the class path
	private String className;
	private String directoryPath;
	private String fileName = "log.log";
	
	// These are required variable for io purposes
	private File file;
	private FileWriter writer;
	
	/**
	 * This constructor creates caches the class name and directory for logging
	 * A new file is created if no existing file is found
	 * This constructor is to be instantiated at the constructor of each class
	 * 
	 * @param className
	 *           class name of the file required to be logged
	 * 
	 * @param directoryPath
	 *           location of the path to be stored
	 */
	public Writer(String className, String directoryPath) { 
		
		this.className = className;
		this.directoryPath = directoryPath;
		
		try {
			
			this.file = new File(this.directoryPath + fileName);
			this.writer = new FileWriter(this.file, true);
			
			
		} catch (IOException e) {
			
			System.out.println(ERROR_WRITE);
			
		}
		
	}
	
	/**
	 * This method writes the error log to both the log file and console
	 * 
	 * @param logType
	 *           specifies the type of log to be classified
	 *           
	 * @param message
	 *           message of the error to be written
	 */
	public String write(LogType logType, String message) {
		
		Calendar calendar = Calendar.getInstance();
	    SimpleDateFormat formatter = new SimpleDateFormat("dd/MM/yyyy HH:mm:ss");
	    
		String result = String.format(STRING_LOG, formatter.format(calendar.getTime()), logType.toString(), this.className, message);
	   
		if(this.writer != null) {
	    	
	    	try {
	    		
	    		this.writer.write(result);
		    	this.writer.flush();
		    	
	    	} catch (IOException e) {
	    		
				System.out.println(ERROR_WRITE);
			
	    	}
	    	
	    }
	    
	    System.out.println(result);
	   
	    return result; 
	    
	}
	
	/**
	 * This method returns the logging file created
	 * 
	 */
	public File getFile() {
		
		return this.file;
	
	}
	
	/**
	 * This method will attempt to close the writer if it exist
	 *
	 */
	public void close() {
		
		if(this.writer != null) {
			
			try {
				
				this.writer.close();
				
			} catch (IOException e) {
				
				System.out.println(ERROR_WRITE);
				
			}
			
		}
		
	}
	
}
```
###### src/notify/logic/parser/CategoryParser.java
``` java

/**
 * Author: Chua Si Hao
 * Matric No: A0125471L
 * For CS2103T - Notify
 */

package notify.logic.parser;

/**
 * This CategoryParser is a helper class to the main CommandParser
 * It assists to identify the category within the command provided
 */
public class CategoryParser {
	
	/**
	 * This method is a helper method to prepare the string into an array 
	 * ready to be parsed by the CategoryParser
	 *
	 */
	public static String parse(String input) { 
		
		String[] params = input.split(Constants.COMMAND_SEPERATOR);
		return parse(params);
	
	}
	
	/**
	 * This method searches the input to find the category hashtag within the command
	 * 
	 * @param input
	 *           the commands in an array seperated by the command seperator
	 * 
	 * @return result
	 *           the category that is found is returned
	 *           if no category is indicated, null is returned
	 *           
	 */
	public static String parse(String[] input) {
		
		String result = null;
		
		for(int i = 0; i < input.length; i++) {

			input[i] = input[i].trim();
			
			if(input[i].equalsIgnoreCase(Constants.STRING_EMPTY) == false) { 
				
				String hashtag = input[i].substring(Constants.HASHTAG_START_INDEX, Constants.HASHTAG_END_INDEX);
				
				if(hashtag.equalsIgnoreCase(Constants.KEYWORD_HASHTAG) == true) {
				
					result = input[i];
					result = result.substring(Constants.HASHTAG_END_INDEX, result.length());
					result = result.trim();
				
				}
				
			}
			
		}
		
		return result;
	
	}
}
```
###### src/notify/logic/parser/CommandParser.java
``` java

/**
 * Author: Chua Si Hao
 * Matric No: A0125471L
 * For CS2103T - Notify
 */

package notify.logic.parser;

import java.util.HashMap;
import java.util.Stack;

import notify.DateRange;
import notify.Task;
import notify.TaskType;
import notify.logic.TaskManager;
import notify.logic.command.Action;
import notify.logic.command.AddCommand;
import notify.logic.command.BackCommand;
import notify.logic.command.Command;
import notify.logic.command.DeleteCommand;
import notify.logic.command.DisplayCommand;
import notify.logic.command.EditCommand;
import notify.logic.command.ExitCommand;
import notify.logic.command.HelpCommand;
import notify.logic.command.MarkCommand;
import notify.logic.command.ReversibleCommand;
import notify.logic.command.SearchCommand;
import notify.logic.command.SetCommand;
import notify.logic.command.UndoCommand;
import notify.storage.api.Storage;

import org.apache.commons.lang3.StringUtils;

/**
 * This class is used to handle the inputs given and converts them into system recognized commands
 */
public class CommandParser {
	
	// These variables are used to interact with the other part of the system instantiated by Logic
	private Storage storage;
	private TaskManager taskManager;
	private Stack<ReversibleCommand> historyStack;
	
	public CommandParser(Storage storage, TaskManager taskManager, Stack<ReversibleCommand> historyStack) {
	
		assert storage != null;
		assert taskManager != null;
		assert historyStack != null;
		
		this.storage = storage;
		this.taskManager = taskManager;
		this.historyStack = historyStack;
	
	}
	
	/**
	 * This method is the main method to be called for commands to be processed
	 * 
	 * @param input is parsed as a string into a system recognized command
	 * 			the corresponding handler is called to process the method
	 * 
	 * @returns Command information is allocated into its corresponding variables 
	 * 				for further processing
	 */
	public Command parse(String input) {
		
		assert input != null;
		input = input.trim();

		Command command = null;
		String[] split = input.split(Constants.COMMAND_SEPERATOR);
		String param = split[Constants.COMMAND_LOCATION_INDEX];
		Action commandAction = retrieveAction(param);
		
		if(commandAction != Action.INVALID) {
		
			int length = split[Constants.COMMAND_LOCATION_INDEX].length();
			input = input.substring(length, input.length()).trim();
		
		}
		
		switch(commandAction) {
		
			case ADD: 
				command = handleAddCommand(commandAction, historyStack, taskManager, input); 
				break;
				
			case BACK: 
				command = handleBackCommand(commandAction, historyStack, taskManager, input); 
				break;
				
			case DELETE: 
				command = handleDeleteCommand(commandAction, historyStack, taskManager, input); 
				break;
				
			case EDIT: 
				command = handleEditCommand(commandAction,historyStack, taskManager, input); 
				break;
				
			case SEARCH: 
				command = handleSearchCommand(commandAction, taskManager, input); 
				break;
				
			case MARK: 
				command = handleMarkCommand(commandAction, historyStack, taskManager, input); 
				break;
				
			case DISPLAY: 
				command = handleDisplayCommand(commandAction, historyStack, taskManager, input); 
				break;
				
			case UNDO: 
				command = handleUndoCommand(commandAction, historyStack, input); 
				break;
				
			case SET: 
				command = handleSetCommand(commandAction, storage, input); 
				break;
			
			case HELP:
				command = handleHelpCommand(commandAction, taskManager);
				break;
				
			case EXIT: 
				command = handleExitCommand(commandAction, taskManager, input); 
				break;
				
			default: 
				throw new IllegalArgumentException(Constants.ERROR_INVALID_COMMAND);			
		
		}
		
		return command;
		
	}
	
	/**
	 * This method handles the add parsing and calls the AddCommand class to process
	 * The name, daterange and category is extracted according the the provided syntax if present
	 */
	private Command handleAddCommand(Action commandAction, Stack<ReversibleCommand> historyStack, TaskManager taskManager, String input) {
		
		String category = CategoryParser.parse(input);
		TaskType taskType = TaskType.FLOATING;
		DateRange dateRange = null;
		String name = input.trim();
		
		if(category != null) { 
			
			int length = category.length() + Constants.KEYWORD_HASHTAG.length();
			input = input.substring(0, input.length() - length);
			
			input = input.trim();
			name = input.trim();
			
		}
		
		//check if command contains any keywords
		String datePrompt = containsKeyword(input, Constants.DATETIME_PROMPT_KEYWORDS);
		String timePrompt = containsKeyword(input, Constants.DATETIME_KEYWORDS);
		String today = Constants.KEYWORD_TODAY[Constants.PARAM_FIRST_INDEX].toLowerCase();
		String[] results = null;
		
		if(datePrompt != null) { 
			
			results = parseDate(input);
						
			if(datePrompt.equalsIgnoreCase(Constants.KEYWORD_FROM)) {
				
				DateRange timeRange = DateTimeParser.parseTimeRange(results[Constants.PARAM_RESULT_DATE]);
				
				if(timeRange != null) {
					
					String processedInput = preProcessDate(input, today);
					datePrompt = containsKeyword(processedInput, Constants.DATETIME_PROMPT_KEYWORDS);
					results = parseDate(processedInput);
					
				} 
				
			}
			
		} else if(timePrompt != null) {
			
			String processedInput = preProcessDate(input, today);
			datePrompt = containsKeyword(processedInput, Constants.DATETIME_PROMPT_KEYWORDS);
			results = parseDate(processedInput);
		
		}
		
		String processedInput = handleShortHand(input, name, results);
		
		if(processedInput != null) {
			
			datePrompt = containsKeyword(processedInput, Constants.DATETIME_PROMPT_KEYWORDS);
			results = parseDate(processedInput);
			
		}
	
		if(datePrompt != null || timePrompt != null) {

			if(results != null) {

				name = results[Constants.PARAM_RESULT_NAME];
				dateRange = DateTimeParser.parseDateRange(results[Constants.PARAM_RESULT_DATE]);
			
				if(datePrompt.equalsIgnoreCase(Constants.KEYWORD_FROM)) {
					
					if(dateRange.isSameDay()) {
						
						taskType = TaskType.DEADLINE;
				
					} else {
						
						taskType = TaskType.RANGE;
				
					}
				
				} else {
			
					taskType = TaskType.DEADLINE;
				
				}
			
			} else {
				
				throw new IllegalArgumentException(Constants.ERROR_INVALID_PARAMS);	
				
			}
		
		}
		
		if(name.equalsIgnoreCase(Constants.STRING_EMPTY)) { 
			
			throw new IllegalArgumentException(Constants.ERROR_INVALID_PARAMS); 
		
		}
		
		name = name.replaceAll(Constants.STRING_ESCAPE, Constants.STRING_EMPTY);
		
		AddCommand command = new AddCommand(commandAction, taskManager, historyStack);
		command.addValues(name, taskType, dateRange, category);
		
		return command;
	
	}
	
	/**
	 * This method handles the back parsing and calls the BackCommand class to process
	 */
	private Command handleBackCommand(Action commandAction, Stack<ReversibleCommand> historyStack, TaskManager taskManager, String input) {
		
		BackCommand command = null;
		
		command = new BackCommand(commandAction, taskManager);
		
		return command;
		
	}
	
	
	/**
	 * This method handles the delete parsing and calls the DeleteCommand class to process
	 * The requested id is extracted from the command
	 * If the id extracted is invalid, an exception is thrown
	 */
	private Command handleDeleteCommand(Action commandAction, Stack<ReversibleCommand> historyStack, TaskManager taskManager, String input) {
		
		DeleteCommand command = null;
		
		String[] split = input.split(Constants.COMMAND_SEPERATOR);
		
		String param = split[Constants.PARAM_FIRST_INDEX];
		boolean isNumeric = StringUtils.isNumeric(param);
		
		if(isNumeric == false) {
		
			throw new IllegalArgumentException(Constants.ERROR_INVALID_PARAMS);
		
		}
		
		int id = Integer.parseInt(split[Constants.PARAM_FIRST_INDEX]);
		
		command = new DeleteCommand(commandAction, historyStack, taskManager);
		command.addValues(id);
		
		return command;
	
	}

	/**
	 * This method handles the edit parsing and calls the EditCommand class to process
	 * The name, daterange and category is extracted according the the provided syntax if present
	 */
	private Command handleEditCommand(Action commandAction, Stack<ReversibleCommand> historyStack, TaskManager taskManager, String input) {
		
		int id = Task.UNASSIGNED_TASK;
		TaskType taskType = null;
		DateRange dateRange = null;
		String category = CategoryParser.parse(input);
		String name = input;
		
		String[] split = input.split(Constants.COMMAND_SEPERATOR);
		
		String param = split[Constants.PARAM_FIRST_INDEX];
		boolean isNumeric = StringUtils.isNumeric(param);
		
		if(isNumeric == false) { 
		
			throw new IllegalArgumentException(Constants.ERROR_INVALID_PARAMS);
		
		}
		
		param = split[Constants.PARAM_FIRST_INDEX];
		id = Integer.parseInt(param);
		
		if(id != Task.UNASSIGNED_TASK) { 
			
			int length = String.valueOf(id).length();
			input = input.substring(length, input.length());
			name = input.trim();
			
		}
	
		if(category != null) { 
			
			int length = category.length() + Constants.KEYWORD_HASHTAG.length();
			input = input.substring(0, input.length() - length);
			
		}

		//check if command contains any keywords
		String datePrompt = containsKeyword(input, Constants.DATETIME_PROMPT_KEYWORDS);
		if(datePrompt != null) { 
			
			String[] results = parseDate(input);
			name = results[Constants.PARAM_RESULT_NAME].trim();
			dateRange = DateTimeParser.parseDateRange(results[Constants.PARAM_RESULT_DATE]);
			
			if(datePrompt.equalsIgnoreCase(Constants.KEYWORD_FROM)) {
				
				if(dateRange.isSameDay() == true) {
					
					taskType = TaskType.DEADLINE;
					
				} else {
					
					taskType = TaskType.RANGE;
					
				}
				
			} else {
				
				taskType = TaskType.DEADLINE;
				
			}
			
		}	
		
		name.replaceAll(Constants.STRING_ESCAPE, Constants.STRING_EMPTY);
		name = name.trim();
		
		if(name.equalsIgnoreCase(Constants.STRING_EMPTY)) { 
			
			name = null; 
		
		}
		
		EditCommand command = new EditCommand(commandAction, historyStack, taskManager);
		command.addValues(name, dateRange, category, id, taskType);

		return command;
		
	}
	
	/**
	 * This method handles the mark parsing and calls the MarkCommand class to process
	 * The requested id is extracted from the command
	 * If the id extracted is invalid, an exception is thrown
	 */
	private Command handleMarkCommand(Action commandAction, Stack<ReversibleCommand> historyStack, TaskManager taskManager, String input) {
		
		MarkCommand command = null;
		
		String[] split = input.split(Constants.COMMAND_SEPERATOR);
		
		String param = split[Constants.PARAM_FIRST_INDEX];
		boolean isNumeric = StringUtils.isNumeric(param);
		
		if(isNumeric == false) {
			
			throw new IllegalArgumentException(Constants.ERROR_INVALID_PARAMS);
		
		}
		
		int id = Integer.parseInt(split[Constants.PARAM_FIRST_INDEX]);
		
		command = new MarkCommand(commandAction, historyStack, taskManager); 
		command.addValues(id);
		
		return command;
		
	}
	
	
	/**
	 * This method handles the search parsing and calls the SearchCommand class to process
	 * The keyword is extracted and passed to SearchCommand class
	 */
	private Command handleSearchCommand(Action commandAction, TaskManager taskManager, String input) {
		
		SearchCommand command = null;
		
		String[] split = input.split(Constants.COMMAND_SEPERATOR);
		String keyword = split[Constants.PARAM_FIRST_INDEX];
		
		command = new SearchCommand(commandAction, taskManager);
		command.addValues(keyword);
		
		return command;
	
	}
	
	
	/**
	 * This method handles the display parsing and calls the DisplayCommand class to process
	 */
	private Command handleDisplayCommand(Action commandAction, Stack<ReversibleCommand> historyStack, TaskManager taskManager, String input) {
		
		DisplayCommand command = null;
		
		command = new DisplayCommand(commandAction, taskManager);
		
		return command;
	
	}
	
	/**
	 * This method handles the undo parsing and calls the UndoCommand class to process
	 */
	private Command handleUndoCommand(Action commandAction, Stack<ReversibleCommand> historyStack, String input) {
		
		UndoCommand command = new UndoCommand(commandAction, historyStack);
		
		return command;
	
	}
	
	/**
	 * This method handles the set command parsing and calls the SetCommand class to process
	 * The file path will be extracted and passed to the SetCommand
	 */
	private Command handleSetCommand(Action commandAction, Storage storage, String input) {
		
		SetCommand command = null;
		
		String[] split = input.split(Constants.COMMAND_SEPERATOR);
		String newFilePath = split[Constants.PARAM_FIRST_INDEX];
		
		command = new SetCommand(commandAction, storage);
		command.addValues(newFilePath);
		
		return command;
		
	}
	
	/**
	 * This method handles the set command parsing and calls the SetCommand class to process
	 * The file path will be extracted and passed to the SetCommand
	 */
	private Command handleHelpCommand(Action commandAction, TaskManager taskManager) {
		
		HelpCommand command = null;
	
		command = new HelpCommand(commandAction, taskManager);

		return command;
		
	}
	
	/**
	 * This method handles the exit command parsing and calls the ExitCommand class to process
	 */
	private Command handleExitCommand(Action commandAction, TaskManager taskManager, String input) {
		
		ExitCommand command = null;
				
		command = new ExitCommand(commandAction, taskManager);
		
		return command;
		
	}
	
	/**
	 * This method checks if the input has been added in a shorthand manner
	 * Where some keywords may be removed to increase efficiency
	 * Method corrects the command to the full form
	 * 
	 * @param input original input received by the parser
	 * 
	 * @param name original name from the earlier parsing
	 * 
	 * @param results results from the earlier parsing
	 * 
	 * @returns String full command that will be system recognized if input is correct
	 * 			returns null if invalid input is given
	 * 
	 */
	private String handleShortHand(String input, String name, String[] results) {
		
		String result = null;
		
		if(results != null) {
			
			name = results[Constants.PARAM_RESULT_NAME];
			
		}
		
		String[] params = name.split(Constants.COMMAND_SEPERATOR);
		String secondLastItem = Constants.STRING_EMPTY;
		String lastItem = Constants.STRING_EMPTY;
		
		if(params.length >= 2 * Constants.OFFSET_ARRAY) {
		
			secondLastItem = params[params.length - 2 * Constants.OFFSET_ARRAY];
		
		}
		
		if(params.length >= Constants.OFFSET_ARRAY) {
		
			lastItem = params[params.length - Constants.OFFSET_ARRAY];
			
		}
		
		if(secondLastItem.equalsIgnoreCase(Constants.KEYWORD_NEXT) || secondLastItem.equalsIgnoreCase(Constants.KEYWORD_THIS)) {
			
			lastItem = String.format(Constants.FORMAT_NEXT_KEYWORD, secondLastItem, lastItem);
			
		}
		
		String[] keywords = Helper.combineArrays(Constants.KEYWORD_ALL_SIZE, Constants.KEYWORD_TODAY, 
										Constants.KEYWORD_TOMORROW, Constants.KEYWORD_NEXT_WEEK, 
										Constants.KEYWORD_NEXT_MONTH, Constants.KEYWORD_NEXT_YEAR, 
										Constants.KEYWORD_MONDAY, Constants.KEYWORD_TUESDAY, 
										Constants.KEYWORD_WEDNESDAY, Constants.KEYWORD_THURSDAY, 
										Constants.KEYWORD_FRIDAY, Constants.KEYWORD_SATURDAY, 
										Constants.KEYWORD_SUNDAY);
		
		String keyword = containsKeyword(lastItem, keywords);
		
		if(keyword != null) {
		
			result = preProcessDate(input, keyword);
			
		}
		 
		return result;

	}
	
	/**
	 * This method checks if the input has been added in a shorthand manner
	 * Where some keywords may be removed to increase efficiency
	 * Method corrects the command to the full form
	 * 
	 * @param input original input received by the parser
	 * 
	 * @param keyword keyword that will be appended into the command
	 * 
	 * @returns String full command that will be system recognized if input is correct
	 * 			returns null if invalid input is given
	 * 
	 */
	private String preProcessDate(String input, String keyword) { 
		
		String compare = input.toUpperCase();
		keyword = keyword.toUpperCase();
		
		String atKeyword = formatKeyword(Constants.KEYWORD_AT, Constants.OPTION_KEYWORD_BOTH);
		String fromKeyword = formatKeyword(Constants.KEYWORD_FROM, Constants.OPTION_KEYWORD_BOTH);
		
		int atIndex = compare.indexOf(atKeyword);
		int fromIndex = compare.indexOf(fromKeyword);
		
		if(atIndex == Constants.KEYWORD_NOT_FOUND) {
			
			atIndex = Integer.MAX_VALUE;
		
		}
		
		if(fromIndex == Constants.KEYWORD_NOT_FOUND) {
		
			fromIndex = Integer.MAX_VALUE;
		
		}
		
		int startIndex = Math.min(atIndex, fromIndex);
		
		String result = Constants.STRING_EMPTY;
		String name = input;
		String rawDate = Constants.STRING_EMPTY;
		
		if(startIndex != Integer.MAX_VALUE) {
			
			name = input.substring(0, startIndex);
			compare = name.toUpperCase();
			
			rawDate = input.substring(startIndex, input.length());
			rawDate = rawDate.trim();

		}
		
		String delete = Constants.STRING_EMPTY;
		
		if(compare.contains(keyword)) { 
		
			delete = compare.substring(compare.length() - keyword.length() , compare.length());
		
		}
		
		if(delete.equalsIgnoreCase(keyword) == true) {
			
			name = name.substring(0, compare.length() - keyword.length());
				
		}
		
		result = String.format(Constants.PARAM_PREPROCESS, name, keyword, rawDate);
		
		return result;	

	}
	
	/**
	 * This converts raw string and date inputs into separate name and daterange
	 * 
	 * @param input
	 *           the string to compute the name and daterange
	 *           
	 * @param results
	 *           the result contains two items
	 *           first item will be the name of the result
	 *           second item will be the daterange object parsed
	 *           
	 */
	private String[] parseDate(String input) {
		
		String compare = input.toUpperCase();
		
		String byKeyword = formatKeyword(Constants.KEYWORD_BY, Constants.OPTION_KEYWORD_BOTH);
		String onKeyword = formatKeyword(Constants.KEYWORD_ON, Constants.OPTION_KEYWORD_BOTH);
		String fromKeyword = formatKeyword(Constants.KEYWORD_FROM, Constants.OPTION_KEYWORD_BOTH);
		
		int byIndex = compare.indexOf(byKeyword);
		int onIndex = compare.indexOf(onKeyword);
		int fromIndex = compare.indexOf(fromKeyword);
		
		if(byIndex == Constants.KEYWORD_NOT_FOUND) {
		
			byIndex = Integer.MAX_VALUE;
		
		}
		
		if(onIndex == Constants.KEYWORD_NOT_FOUND) {
		
			onIndex = Integer.MAX_VALUE;
		
		}
		
		if(fromIndex == Constants.KEYWORD_NOT_FOUND) {
		
			fromIndex = Integer.MAX_VALUE;
		
		}
		
		String[] results = null;
		int startIndex = Math.min(Math.min(byIndex, onIndex), fromIndex);
		
		if(startIndex != Integer.MAX_VALUE) { 
		
			results = new String[Constants.PARAM_RESULT_SIZE];
			results[Constants.PARAM_RESULT_NAME] = input.substring(0, startIndex);
			results[Constants.PARAM_RESULT_DATE] = input.substring(startIndex, input.length());
		
		}
		
		return results;	
	
	}
	
	/**
	 * This method checks for keyword in the input and returns the keyword found
	 * 
	 * @param input
	 *           the string to search keywords within
	 *           
	 * @param list
	 *           array of keywords to search against
	 *           
	 */
	private String containsKeyword(String input, String[] list) {
			
		String result = null;
		
		for(int i = 0; i < list.length && result == null; i++) {

			input = input.toUpperCase();
			input = formatKeyword(input, Constants.OPTION_KEYWORD_BOTH);
			
			list[i] = list[i].trim();
			list[i] = formatKeyword(list[i], Constants.OPTION_KEYWORD_BOTH);
						
			int index = input.indexOf(list[i]);
			
			if(index != Constants.KEYWORD_NOT_FOUND) {
				
				String escape = Constants.STRING_EMPTY;
				
				if(index != Constants.KEYWORD_NOT_ESCAPED) {
					
					escape = input.substring(index - Constants.STRING_ESCAPE.length(), index);
					
				}
				
				if(escape.equalsIgnoreCase(Constants.STRING_ESCAPE) == false) {
				
					result = list[i].trim();
				
				}
			
			}
		
		}
		
		return result;
	
	}
	
	/**
	 * This method retrieves the keyword and process it into the appropriate format
	 * 
	 * @param keyword
	 *           phase to be process with padding
	 * 
	 * @param options
	 *           the option of the way the keyword should be formatted
	 *           
	 */
	public static String formatKeyword(String keyword, int options) {
		
		String result = null;
		keyword = keyword.trim();
		
		switch(options) {
		
			case Constants.OPTION_KEYWORD_FRONT:
				result = String.format(Constants.FORMAT_KEYWORD_FRONT, keyword);
				break;
		
			case Constants.OPTION_KEYWORD_BACK:
				result = String.format(Constants.FORMAT_KEYWORD_BACK, keyword);
				break;
			
			case Constants.OPTION_KEYWORD_BOTH:
				result = String.format(Constants.FORMAT_KEYWORD_BOTH, keyword);
				break;
			
			default:
				result = keyword;
			
		}
		
		return result;
		
	}
	
	/**
	 * This method retrieves the corresponding Action based on the string entered
	 * 
	 * @param action
	 *           name of the action to be processed
	 * 
	 * @return Action
	 *           the corresponding Action based on input string
	 *           invalid action is returned if no match is found
	 *           
	 */
	private Action retrieveAction(String action) {
		
		assert storage != null;
		
		Action result = Action.INVALID;
		action = action.toUpperCase();
		
		HashMap<String, Action> commandVariations = this.storage.loadCommands();

		if(commandVariations.containsKey(action)) {
		
			result = commandVariations.get(action); 
		
		}
		
		return result;
	
	}
	
}
```
###### src/notify/logic/parser/Constants.java
``` java

/**
 * Author: Chua Si Hao
 * Matric No: A0125471L
 * For CS2103T - Notify
 */

package notify.logic.parser;

import java.util.Calendar;

/**
 * This Constants class stores all the shared variables required in the various
 * components of the parser package
 */
public class Constants {
	
	/** Shared Constant Variables - String **/
	public static final String STRING_EMPTY = "";
	public static final String STRING_SPACE = " ";
	public static final String STRING_ESCAPE = "/";
	
	/** Shared Constant Variables - Integer **/
	public static final int INT_ZERO = 0;
	
	/** Category Parser Constants **/
	public static final int HASHTAG_START_INDEX = 0;
	public static final int HASHTAG_END_INDEX = 1;
	public static final String KEYWORD_HASHTAG = "#";
	
	
	/** Command Parser Constants **/
	public static final int OPTION_KEYWORD_FRONT = 0;
	public static final int OPTION_KEYWORD_BACK = 1;
	public static final int OPTION_KEYWORD_BOTH = 2;
	public static final String FORMAT_KEYWORD_FRONT = " %1$s";
	public static final String FORMAT_KEYWORD_BACK = "%1$s ";
	public static final String FORMAT_KEYWORD_BOTH = " %1$s ";
	
	public static final String COMMAND_SEPERATOR = " ";
	public static final int COMMAND_LOCATION_INDEX = 0;
	
	public static final int KEYWORD_NOT_FOUND = -1;
	public static final int KEYWORD_NOT_ESCAPED = 0;
	
	public static final int PARAM_RESULT_SIZE = 2;
	public static final int PARAM_RESULT_NAME = 0;
	public static final int PARAM_RESULT_DATE = 1;
	public static final int PARAM_RESULT_SINGLE = 1;
	
	public static final int PARAM_FIRST_INDEX = 0;
	public static final int PARAM_SECOND_INDEX = 1;
	public static final int PARAM_THIRD_INDEX = 2;
	
	public static final String PARAM_PREPROCESS = "%1$s on %2$s %3$s";
	
	/** Date Time Parser Constants **/
	public static final String[] DATETIME_PROMPT_KEYWORDS = { "BY", "ON", "FROM" };
	public static final String[] DATETIME_KEYWORDS = { "AT", "FROM", "TO" };
	public static final String KEYWORD_BY = DATETIME_PROMPT_KEYWORDS[0];
	public static final String KEYWORD_ON = DATETIME_PROMPT_KEYWORDS[1];
	public static final String KEYWORD_FROM = DATETIME_PROMPT_KEYWORDS[2];
	public static final String KEYWORD_AT = DATETIME_KEYWORDS[0];
	public static final String KEYWORD_TO = DATETIME_KEYWORDS[2];
	public static final int KEYWORD_PROMPT_INDEX = 0;
	
	public static final String[] KEYWORD_TODAY = { "TODAY", "TDY", "LATER" };
	public static final String[] KEYWORD_TOMORROW = { "TOMORROW", "TMR", "TMRW" };
	public static final String[] KEYWORD_NEXT_WEEK = { "NEXT WEEK" };
	public static final String[] KEYWORD_NEXT_MONTH = { "NEXT MONTH" };
	public static final String[] KEYWORD_NEXT_YEAR = { "NEXT YEAR" };
	public static final String[] KEYWORD_MONDAY = { "THIS MONDAY", "THIS MON", "NEXT MONDAY", "NEXT MON", "MONDAY", "MON" };
	public static final String[] KEYWORD_TUESDAY = { "THIS TUESDAY", "THIS TUES", "THIS TUE", 
													"NEXT TUESDAY", "NEXT TUE", "NEXT TUES", "TUESDAY", "TUE", "TUES"};
	public static final String[] KEYWORD_WEDNESDAY = { "THIS WEDNESDAY", "THIS WED", "NEXT WEDNESDAY", "NEXT WED", "WEDNESDAY", "WED" };
	public static final String[] KEYWORD_THURSDAY =	{ "THIS THURSDAY", "THIS THURS", "THIS THUR", "NEXT THURSDAY", "NEXT THU", 
													  "NEXT THURSDAY", "THURSDAY", "THU", "THURS" }; 
	public static final String[] KEYWORD_FRIDAY	= { "THIS FRIDAY", "THIS FRI", "NEXT FRIDAY", "NEXT FRI", "FRIDAY", "FRI" };
	public static final String[] KEYWORD_SATURDAY =	{ "THIS SATURDAY", "THIS SAT", "NEXT SATURDAY", "NEXT SAT", "SATURDAY", "SAT" }; 
	public static final String[] KEYWORD_SUNDAY	= { "THIS SUNDAY", "NEXT SUN", "NEXT SUNDAY", "NEXT SUN", "SUNDAY", "SUN" };
	public static final String KEYWORD_NEXT = "NEXT";
	public static final String KEYWORD_THIS = "THIS";
	public static final int KEYWORD_ALL_SIZE = 57; 
	public static final int KEYWORD_DAY_SIZE = 48; 
	public static final String FORMAT_NEXT_KEYWORD = "%1$s %2$s";
	
	public static final int PARAM_DATE = 0;
	public static final int PARAM_TIME = 1;
	public static final int PARAM_FROM = 0; 
	public static final int PARAM_TO = 1;
	
	public static final String DATE_SEPERATOR_SLASH = "\\/";
	public static final String DATE_SEPERATOR_SPACE = " ";
	public static final int DATE_SEPERATOR_MIN = 2;
	public static final int DATE_SEPERATOR_MAX = 3;
	
	public static final int DATE_DAY_MIN = 1;
	public static final int DATE_DAY_MAX = 31;
	public static final int DATE_MONTH_MIN = Calendar.JANUARY;
	public static final int DATE_MONTH_MAX = Calendar.DECEMBER;
	public static final int DATE_YEAR_MIN = 1900;
	public static final int DATE_YEAR_MAX = 2100;
	
	public static final int TIME_HOUR_MIN = 0;
	public static final int TIME_HOUR_MAX = 23;
	public static final int TIME_MINUTE_MIN = 0;
	public static final int TIME_MINUTE_MAX = 59;
	public static final int TIME_DIFFERENCE = 12;
	
	public static final int OFFSET_ARRAY = 1;
	public static final int OFFSET_DAY = 1;
	public static final int OFFSET_WEEK = 7;
	public static final int OFFSET_MONTH = 1;
	public static final int OFFSET_YEAR = 1;
	public static final int OFFSET_DOUBLE = 2;
	public static final int OFFSET_RESET = 1;
	
	public static final int DEFAULT_YEAR = 0;
	public static final int DEFAULT_MONTH = 0;
	public static final int DEFAULT_DAY = 1;
	public static final int DEFAULT_HOUR = 0;
	public static final int DEFAULT_MINUTE = 0;
	public static final int DEFAULT_SECOND = 0;
	
	public static final int TIME_FORMAT_ONE = 1; //eg. 9pm, 8am
	public static final int TIME_FORMAT_TWO = 2; //eg. 12am, 12pm
	public static final int TIME_FORMAT_THREE = 3; //eg. 130am 
	public static final int TIME_FORMAT_FOUR = 4; //eg. 0130pm 2359
	public static final int TIME_FORMAT_SIZE = 1;
	public static final int TIME_FORMAT_MAX = 6;
	
	public static final int PARAM_DAY = 0;
	public static final int PARAM_MONTH = 1;
	public static final int PARAM_YEAR = 2;
	
	public static final String FORMAT_INTEGER_APPEND = "0%1$s";
	public static final int FORMAT_INTEGER_SINGLE = 1;
	
	public static final int INVALID_YEAR = -1;
	
	
	/** Parser Error Messages **/
	public static final String ERROR_INVALID_COMMAND = "Unable to parse command. Invalid command provided.";
	public static final String ERROR_INVALID_PARAMS = "Unable to recognize parameter(s) entered.";
	public static final String ERROR_INVALID_DATE = "You have entered an invalid date.";
	
}
```
###### src/notify/logic/parser/DateTimeParser.java
``` java

/**
 * Author: Chua Si Hao
 * Matric No: A0125471L
 * For CS2103T - Notify
 */

package notify.logic.parser;

import java.util.Calendar;

import org.apache.commons.lang3.StringUtils;

import notify.DateRange;

/**
 * This DateTimeParser class handles both date and time parsing from raw inputs
 */
public class DateTimeParser {
	
	/**
	 * Returns an defaulted instance of the Calendar object
	 * Values are set to the defaults indicated in the Constants class
	 * 
	 * @return Calendar defaulted values are returned
	 * 
	 */
	public static Calendar getInstance() {
		
		Calendar result = Calendar.getInstance();
		
		result.set(Constants.DEFAULT_YEAR, Constants.DEFAULT_MONTH, Constants.DEFAULT_DAY, 
				Constants.DEFAULT_HOUR, Constants.DEFAULT_MINUTE, Constants.DEFAULT_SECOND);
		
		return result;
	}
	
	/**
	 * Handles the analyzing of date range from its raw input
	 * Information is parsed and a DateRange object with the values is populated
	 * 
	 * @param rawDateTime unprocessed string of information to be parsed
	 * 
	 * @returns DateRange values are populated into the DateRange
	 * 					values within the DateRange will be null if not provided
	 * 
	 */
	public static DateRange parseDateRange(String rawDateTime) {
		
		rawDateTime = rawDateTime.toUpperCase().trim();
		
		DateRange dateRange = new DateRange();
		
		 String byKeyword = CommandParser.formatKeyword(Constants.KEYWORD_BY, Constants.OPTION_KEYWORD_BACK);
	     String onKeyword = CommandParser.formatKeyword(Constants.KEYWORD_ON, Constants.OPTION_KEYWORD_BACK);
	     String fromKeyword = CommandParser.formatKeyword(Constants.KEYWORD_FROM, Constants.OPTION_KEYWORD_BACK);
	     String toKeyword =  CommandParser.formatKeyword(Constants.KEYWORD_TO, Constants.OPTION_KEYWORD_BOTH);
	     String atKeyword =  CommandParser.formatKeyword(Constants.KEYWORD_AT, Constants.OPTION_KEYWORD_BOTH);
	     
		int byIndex = rawDateTime.indexOf(byKeyword);
		int onIndex = rawDateTime.indexOf(onKeyword);
		int fromIndex = rawDateTime.indexOf(fromKeyword);;
		int toIndex = rawDateTime.indexOf(toKeyword);
	
		//case one: contains 'by' or 'on', check for at (start/time date = today, end/time date = given)
		if(byIndex == Constants.KEYWORD_PROMPT_INDEX || onIndex == Constants.KEYWORD_PROMPT_INDEX) {
			rawDateTime = rawDateTime.substring(Constants.KEYWORD_BY.length(), rawDateTime.length());
			
			toKeyword = CommandParser.formatKeyword(Constants.KEYWORD_TO, Constants.OPTION_KEYWORD_BOTH);
			fromKeyword = CommandParser.formatKeyword(Constants.KEYWORD_FROM, Constants.OPTION_KEYWORD_BOTH);
			
			int atIndex = rawDateTime.indexOf(atKeyword);
			toIndex = rawDateTime.indexOf(toKeyword);
			fromIndex = rawDateTime.indexOf(fromKeyword); 
						
			if(atIndex != Constants.KEYWORD_NOT_FOUND) {
				
				String[] split = rawDateTime.split(atKeyword);
				String date = split[Constants.PARAM_DATE].trim();
				String time = split[Constants.PARAM_TIME].trim();
						
				dateRange.setEndDate(date);
				dateRange.setEndTime(time);
			
			//case two: contains 'on', check for from and to 
			} else if (fromIndex != Constants.KEYWORD_NOT_FOUND && toIndex != Constants.KEYWORD_NOT_FOUND) {
				
				if(toIndex <= fromIndex) { 
				
					throw new IllegalArgumentException(Constants.ERROR_INVALID_DATE);
				
				}
				
				String[] split = rawDateTime.split(Constants.KEYWORD_FROM);
				String date = split[Constants.PARAM_DATE];
				dateRange.setStartDate(date);
				dateRange.setEndDate(date);
				
				split = split[Constants.PARAM_TIME].split(Constants.KEYWORD_TO);
				String fromTime = split[Constants.PARAM_FROM];
				String toTime = split[Constants.PARAM_TO];
				
				dateRange.setStartTime(fromTime);
				dateRange.setEndTime(toTime);	
			
			} else {
				
				dateRange.setEndDate(rawDateTime);
				
			}
			
		//case three: from and to (search for at in within)	
		} else if(fromIndex == Constants.KEYWORD_PROMPT_INDEX && toIndex != Constants.KEYWORD_NOT_FOUND) {
			
			if(toIndex <= fromIndex) { 
				
				throw new IllegalArgumentException(Constants.ERROR_INVALID_DATE);
				
			}

			rawDateTime = rawDateTime.substring(Constants.KEYWORD_FROM.length(), rawDateTime.length());
			toKeyword = CommandParser.formatKeyword(Constants.KEYWORD_TO, Constants.OPTION_KEYWORD_BOTH);
			
			String[] split = rawDateTime.split(toKeyword);
			String startDateTime = split[Constants.PARAM_FROM];
			String endDateTime = split[Constants.PARAM_TO];	
			
			int atIndex = startDateTime.indexOf(Constants.KEYWORD_AT);
			
			if(atIndex != Constants.KEYWORD_NOT_FOUND) {
			
				split = startDateTime.split(Constants.KEYWORD_AT);
				dateRange.setStartDate(split[Constants.PARAM_DATE]);
				dateRange.setStartTime(split[Constants.PARAM_TIME]);
			
			} else {
			
				dateRange.setStartDate(startDateTime);
			
			}

			atIndex = endDateTime.indexOf(Constants.KEYWORD_AT);
			
			if(atIndex != Constants.KEYWORD_NOT_FOUND) {
			
				split = endDateTime.split(Constants.KEYWORD_AT);
				dateRange.setEndDate(split[Constants.PARAM_DATE]);
				dateRange.setEndTime(split[Constants.PARAM_TIME]);
			
			} else {
			
				dateRange.setEndDate(endDateTime);
			
			}
			
		}
	
		return dateRange;
	
	}
	
	/**
	 * Handles the analyzing of date from its raw input
	 * Information is parsed and a Calendar object with the values is populated
	 * 
	 * @param rawDate unprocessed string of information to be parsed
	 * 
	 * @returns Calendar values are populated into the Calendar
	 * 				Fields within the Calendar object that is not specified will be defaulted
	 * 
	 */
	public static Calendar parseDate(String rawDate) {
		
		assert rawDate != null;
		
		Calendar result = null;
		
		// check if raw date contains time, parse it accordingly
		boolean dateFound = false;
		
		// search for all possible keywords of today
		for(int i = 0; i < Constants.KEYWORD_TODAY.length; i++) {
		
			if(rawDate.equalsIgnoreCase(Constants.KEYWORD_TODAY[i])) {
			
				result = Calendar.getInstance();
				dateFound = true;
		
			}
		
		}
		
		
		// search for all possible keywords of tomorrow
		for(int i = 0; i < Constants.KEYWORD_TOMORROW.length; i++) {
			
			if(rawDate.equalsIgnoreCase(Constants.KEYWORD_TOMORROW[i])) {
			
				result = Calendar.getInstance();
				result.add(Calendar.DATE, Constants.OFFSET_DAY);
				dateFound = true;
			
			}
		
		}
		
		//search for all possible keywords of next week
		for(int i = 0; i < Constants.KEYWORD_NEXT_WEEK.length; i++) {
		
			if(rawDate.equalsIgnoreCase(Constants.KEYWORD_NEXT_WEEK[i])) {
			
				result = Calendar.getInstance();
				result.add(Calendar.DATE, Constants.OFFSET_WEEK);
				dateFound = true;
			
			}
		
		}
		
		//search for all possible keywords of next month
		for(int i = 0; i < Constants.KEYWORD_NEXT_MONTH.length; i++) {
		
			if(rawDate.equalsIgnoreCase(Constants.KEYWORD_NEXT_MONTH[i])) {
			
				result = Calendar.getInstance();
				result.add(Calendar.MONTH, Constants.OFFSET_MONTH);
				dateFound = true;
			
			}
		
		}
		
		//search for all possible keywords of next year
		for(int i = 0; i < Constants.KEYWORD_NEXT_YEAR.length; i++) {
		
			if(rawDate.equalsIgnoreCase(Constants.KEYWORD_NEXT_YEAR[i])) {
			
				result = Calendar.getInstance();
				result.add(Calendar.YEAR, Constants.OFFSET_YEAR);
				dateFound = true;
			
			}
		
		}
		
		//check for days keyword
		if(dateFound == false) {
	
			result = retrieveNext(rawDate);
			
			if(result != null) {
				
				dateFound = true;

			}

		}
		
		//if date entered is not a keyword, check if date is separated by slashes
		if(dateFound == false) {
		
			Calendar today = Calendar.getInstance();
			String[] split = rawDate.split(Constants.DATE_SEPERATOR_SLASH);
	
			if(split.length >= Constants.DATE_SEPERATOR_MIN) {
				
				String dayInput = split[Constants.PARAM_DAY];
				String monthInput = split[Constants.PARAM_MONTH];
				
				int day = retrieveDay(dayInput);
				int month = retrieveMonth(monthInput);
				int year = retrieveYear(null);
			
				if(split.length == Constants.DATE_SEPERATOR_MAX) {
					
					String yearInput = split[Constants.PARAM_YEAR];
					year = retrieveYear(yearInput);
				
				}
				
				result = Calendar.getInstance();
				result.set(Calendar.DATE, day);
				result.set(Calendar.MONTH, month);
				result.set(Calendar.YEAR, year);
				
				//indicates that year is not added
				if(split.length < Constants.DATE_SEPERATOR_MAX) {
					
					if(result.before(today)) {
						
						result.set(Calendar.YEAR, year + Constants.OFFSET_YEAR);
						
					}
					
				}
				
				dateFound = true;
			
			}
		
		}
		
		//check if date is separated by spaces
		if(dateFound == false) {
		
			Calendar today = Calendar.getInstance();
			String[] split = rawDate.split(Constants.DATE_SEPERATOR_SPACE);
	
			if(split.length >= Constants.DATE_SEPERATOR_MIN) {
				
				String dayInput = split[Constants.PARAM_DAY];
				String monthInput = split[Constants.PARAM_MONTH];
				
				int day = retrieveDay(dayInput);
				int month = retrieveMonth(monthInput);
				int year = retrieveYear(null);
				
				if(split.length == Constants.DATE_SEPERATOR_MAX) {
					
					String yearInput = split[Constants.PARAM_YEAR];
					year = retrieveYear(yearInput);
				
				}
				
				result = Calendar.getInstance();
				result.set(Calendar.DATE, day);
				result.set(Calendar.MONTH, month);
				result.set(Calendar.YEAR, year);
				
				//indicates that year is not added
				if(split.length < Constants.DATE_SEPERATOR_MAX) {
					
					if(result.before(today)) {
						
						result.set(Calendar.YEAR, year + Constants.OFFSET_YEAR);
						
					}
					
				}
				
				dateFound = true;
				
			}
			
		}
		
		if(dateFound == false) { 
			
			throw new IllegalArgumentException(Constants.ERROR_INVALID_DATE);
		
		}
		
		return result;
	
	}
	
	/**
	 * Validates and return the day if is in correct format
	 */
	private static int retrieveDay(String day) {
		
		boolean isNumeric = StringUtils.isNumeric(day);
		
		if(isNumeric == false) { 
		
			throw new IllegalArgumentException(Constants.ERROR_INVALID_DATE);
		
		}
		
		int result = Integer.parseInt(day);
		
		if(result < Constants.DATE_DAY_MIN || result > Constants.DATE_DAY_MAX) {
		
			throw new IllegalArgumentException(Constants.ERROR_INVALID_DATE);
		
		}
		
		return result;		
	}
	
	/**
	 * Validates and return the month if is in correct format
	 */
	private static int retrieveMonth(String month) {
		
		int result = -1;
		
		boolean isNumeric = StringUtils.isNumeric(month);
		
		if(isNumeric == true) {
		
			result = Integer.parseInt(month) - Constants.OFFSET_MONTH;
		
		} else {
		
			result = Month.retrieve(month).getValue();
			
			if(result < Constants.DATE_MONTH_MIN || result > Constants.DATE_MONTH_MAX) {
			
				throw new IllegalArgumentException(Constants.ERROR_INVALID_DATE);
			
			}
		
		}
		
		return result;
	
	}
	
	/**
	 * Validates and return the year if is in correct format
	 */
	private static int retrieveYear(String year) {
		
		int result = Constants.INVALID_YEAR;
		
		if(year == null) { 
		
			result = Calendar.getInstance().get(Calendar.YEAR);
			year = String.valueOf(result);
		
		}

		boolean isNumeric = StringUtils.isNumeric(year);
		
		if(isNumeric == true) {
		
			result = Integer.parseInt(year);
		
		} else { 
		
			throw new IllegalArgumentException(Constants.ERROR_INVALID_DATE);
		
		}
		
		if(result < Constants.DATE_YEAR_MIN || result > Constants.DATE_YEAR_MAX) {
		
			throw new IllegalArgumentException(Constants.ERROR_INVALID_DATE);
		
		}
		
		return result;
	
	}

	/**
	 * Search for the corresponding Calendar's Day with the keyword provided
	 */
	private static int retrieveDayIndex(String day) { 
		
		int dayOfWeek = Constants.INT_ZERO;
		day = day.toUpperCase();
		
		for(int i = 0; i < Constants.KEYWORD_MONDAY.length; i++) {
			
			if(day.contains(Constants.KEYWORD_MONDAY[i])) {
			
				dayOfWeek = Calendar.MONDAY;
				
			}
			
		}
		
		for(int i = 0; i < Constants.KEYWORD_TUESDAY.length; i++) {
			
			if(day.contains(Constants.KEYWORD_TUESDAY[i])) {
			
				dayOfWeek = Calendar.TUESDAY;
				
			}
			
		}
		
		for(int i = 0; i < Constants.KEYWORD_WEDNESDAY.length; i++) {
			
			if(day.contains(Constants.KEYWORD_WEDNESDAY[i])) {
			
				dayOfWeek = Calendar.WEDNESDAY;
				
			}
			
		}
		
		for(int i = 0; i < Constants.KEYWORD_THURSDAY.length; i++) {
			
			if(day.contains(Constants.KEYWORD_THURSDAY[i])) {
			
				dayOfWeek = Calendar.THURSDAY;
				
			}
			
		}
		
		for(int i = 0; i < Constants.KEYWORD_FRIDAY.length; i++) {
			
			if(day.contains(Constants.KEYWORD_FRIDAY[i])) {
			
				dayOfWeek = Calendar.FRIDAY;
				
			}
			
		}
		
		for(int i = 0; i < Constants.KEYWORD_SATURDAY.length; i++) {
			
			if(day.contains(Constants.KEYWORD_SATURDAY[i])) {
			
				dayOfWeek = Calendar.SATURDAY;
				
			}
			
		}
		
		for(int i = 0; i < Constants.KEYWORD_SUNDAY.length; i++) {
			
			if(day.contains(Constants.KEYWORD_SUNDAY[i])) {
			
				dayOfWeek = Calendar.SUNDAY;
				
			}
			
		}
		
		return dayOfWeek;
		
	}
	
	/**
	 * Find the following corresponding day or the day on the next week
	 * Information is parsed and a Calendar object with the values is populated
	 * 
	 * @param day the closest day that matches request
	 * 
	 * @returns Calendar values are populated into the Calendar
	 * 				Fields within the Calendar object that is not specified will be defaulted
	 * 
	 */
	private static Calendar retrieveNext(String day) {
		
		Calendar results = null;
		Calendar today = Calendar.getInstance();
		int dayIndex = retrieveDayIndex(day);
		boolean found = false;
		
		day = day.toUpperCase();
		
		int offset;
		int current = today.get(Calendar.DAY_OF_WEEK);
		
		for(offset = 0; offset <= Constants.OFFSET_WEEK; offset++) { 
			
			if(current >= Constants.OFFSET_WEEK + Constants.OFFSET_DAY) { 
				
				current = Constants.OFFSET_RESET; 
			
			}  
			
			if(current == dayIndex) {
				
				found = true;
				break;
				
			}
			
			current++;
			
		}
		
		if(day.contains(Constants.KEYWORD_NEXT) == true) {
			
			offset += Constants.OFFSET_WEEK;
			
		}
		
		offset = today.get(Calendar.DAY_OF_YEAR) + offset;
		today.set(Calendar.DAY_OF_YEAR, offset);
		
		if(found == true) { 
			
			results = today;
			
		}
		
		return results;
		
	}
	
	/**
	 * Handles the analyzing of time range from its raw input
	 * Information is parsed and a Calendar object with only start and end time
	 * 
	 * @param rawRange unprocessed string of information to be parsed
	 * 
	 * @returns DateRange values are populated into the Calendar
	 * 				Fields within the Calendar object that is not specified will be defaulted
	 * 
	 */
	public static DateRange parseTimeRange(String rawRange) {
		
		assert rawRange != null;

		rawRange = rawRange.trim();
		rawRange = rawRange.toUpperCase();
		rawRange = rawRange.replaceAll(Constants.KEYWORD_FROM, Constants.STRING_EMPTY);
		
		String[] split = rawRange.split(Constants.KEYWORD_TO);
		
		DateRange dateRange = null;
		
		if(split.length == Constants.PARAM_RESULT_SIZE) { 
			
			String startTime = split[Constants.PARAM_FROM];
			String endTime = split[Constants.PARAM_TO];
			
			if(startTime.length() <= Constants.TIME_FORMAT_MAX 
					&& endTime.length() <= Constants.TIME_FORMAT_MAX) {
				
				dateRange = new DateRange(null, startTime, null, endTime);
				
			}
		}
		
		return dateRange;

	}

	/**
	 * Handles the analyzing of time from its raw input
	 * Information is parsed and a Calendar object with the values is populated
	 * 
	 * @param rawTime unprocessed string of information to be parsed
	 * 
	 * @returns Calendar values are populated into the Calendar
	 * 				Fields within the Calendar object that is not specified will be defaulted
	 * 
	 */
	public static Calendar parseTime(String rawTime) {
		
		assert rawTime != null;

		rawTime = rawTime.trim();
		
		int hour = 0; 
		int minute = 0;
		boolean isPostMeridiem = false;
		Calendar calendar = getInstance();
		
		if(rawTime.length() >= Constants.TIME_FORMAT_THREE) {
			
			String am = Meridiem.AM.toString();
			String pm = Meridiem.PM.toString();
			
			String meridiem = rawTime.substring(rawTime.length() - am.length(), rawTime.length());
			
			if(meridiem.equalsIgnoreCase(am) == true || meridiem.equalsIgnoreCase(pm) == true) {
			
				isPostMeridiem = meridiem.equalsIgnoreCase(pm);
				rawTime = rawTime.substring(0, rawTime.length() - am.length());
			
			}
			
		}
		
		boolean isNumeric = StringUtils.isNumeric(rawTime);
		
		if(isNumeric == false) {
			
			throw new IllegalArgumentException(Constants.ERROR_INVALID_DATE);
		
		}

		// Used to handle time format such as 9am, 12pm
		if(rawTime.length() == Constants.TIME_FORMAT_ONE || rawTime.length() == Constants.TIME_FORMAT_TWO) {
		
			hour = Integer.parseInt(rawTime);
			minute = Constants.DEFAULT_MINUTE;
		
		// Used to handle time format such as 930am
		} else if(rawTime.length() == Constants.TIME_FORMAT_THREE) {
		
			hour = Integer.parseInt(rawTime.substring(Constants.PARAM_FIRST_INDEX, Constants.PARAM_SECOND_INDEX));
			minute = Integer.parseInt(rawTime.substring(Constants.PARAM_SECOND_INDEX, rawTime.length()));
	
		// Used to handle time format such as 1030pm, 2359
		} else if(rawTime.length() == Constants.TIME_FORMAT_FOUR) {
		
			hour = Integer.parseInt(rawTime.substring(Constants.PARAM_FIRST_INDEX, Constants.PARAM_THIRD_INDEX));
			minute = Integer.parseInt(rawTime.substring(Constants.PARAM_THIRD_INDEX, rawTime.length()));
		
		// If it does not fall within any of the category, an exception is thrown
		} else {
			
			throw new IllegalArgumentException(Constants.ERROR_INVALID_DATE);
		
		}
		
		// handle the meridiem offset, from meridiem format to 24 hours time format
		if(isPostMeridiem == true) {
			
			if(hour != Constants.TIME_DIFFERENCE) {
				
				hour = hour + Constants.TIME_DIFFERENCE;
				
			}
		
		} else {

			if(hour == Constants.TIME_DIFFERENCE) {
				
				hour = hour - Constants.TIME_DIFFERENCE;
			
			}
	
		}
		
		if(hour < Constants.TIME_HOUR_MIN || hour > Constants.TIME_HOUR_MAX) { 
		
			throw new IllegalArgumentException(Constants.ERROR_INVALID_DATE);
		
		}
		
		if(minute < Constants.TIME_MINUTE_MIN || minute > Constants.TIME_MINUTE_MAX) {
		
			throw new IllegalArgumentException(Constants.ERROR_INVALID_DATE);
		
		}
		
		calendar.set(Calendar.HOUR_OF_DAY, hour);
		calendar.set(Calendar.MINUTE, minute);
		
		return calendar;
	
	}
}
```
###### src/notify/logic/parser/Helper.java
``` java

/**
 * Author: Chua Si Hao
 * Matric No: A0125471L
 * For CS2103T - Notify
 */
package notify.logic.parser;

/**
 * This Helper class contains quick hand methods to manipulate data
 */
public class Helper {

	/**
	 * Takes a list of String[] and combine them into one
	 */
	public static String[] combineArrays(int size, String[]... arrays) {
		
		int count = 0;
		String[] results = new String[size];
		
		for(int i = 0; i < arrays.length; i++) { 
			
			String[] item = arrays[i];
			
			for(int x = 0; x < item.length; x++) { 
				
				results[count] = item[x];
				count++;
				
			}
			
		}
		
		return results;
		
	}
	
}
```
###### src/notify/logic/parser/Meridiem.java
``` java

/**
 * Author: Chua Si Hao
 * Matric No: A0125471L
 * For CS2103T - Notify
 */

package notify.logic.parser;

/**
 * This Meridiem enumeration indicates the list of meridiem the system supports
 */
public enum Meridiem {
	
	AM, PM

}
```
###### src/notify/logic/parser/Month.java
``` java

/**
 * Author: Chua Si Hao
 * Matric No: A0125471L
 * For CS2103T - Notify
 */

package notify.logic.parser;

import java.util.Calendar;

/**
 * This Month enumeration indicates the list of months the system supports
 */
public enum Month {
	
	JAN			(Calendar.JANUARY), 
	FEB 		(Calendar.FEBRUARY), 
	MAR 		(Calendar.MARCH),
	APR 		(Calendar.APRIL), 
	MAY 		(Calendar.MAY),
	JUN 		(Calendar.JUNE), 
	JUL 		(Calendar.JULY),
	AUG 		(Calendar.AUGUST),
	SEP			(Calendar.SEPTEMBER),
	OCT 		(Calendar.OCTOBER), 
	NOV 		(Calendar.NOVEMBER),
	DEC 		(Calendar.DECEMBER),
	INVALID 	(-1);
	
	// These are the variables required to store corresponding for each month
	private int value; 
	
	private Month(int value) {
		
		this.value = value;
	
	}
	
	/**
	 * This method returns value associated with the month object
	 * 
	 */
	public int getValue() {
		
		return this.value;

	}
	
	/**
	 * This method reads the string input and converts it into
	 * its corresponding month enum
	 * 
	 * @param month
	 *           name of month to be converted
	 * 
	 * @return Month
	 *           the corresponding month based on input string
	 *           invalid month is returned if invalid string is given
	 *           
	 */
	public static Month retrieve(String month) {
		
		Month selected =  Month.INVALID;
		
		if(month.equalsIgnoreCase(Month.JAN.toString())) {
			
			selected = Month.JAN;
		
		} else if(month.equalsIgnoreCase(Month.FEB.toString())) {
		
			selected = Month.FEB;
		
		} else if(month.equalsIgnoreCase(Month.MAR.toString())) {
		
			selected = Month.MAR;
		
		} else if(month.equalsIgnoreCase(Month.APR.toString())) {
		
			selected = Month.APR;
		
		} else if(month.equalsIgnoreCase(Month.MAY.toString())) {
		
			selected = Month.MAY;
		
		} else if(month.equalsIgnoreCase(Month.JUN.toString())) {
		
			selected = Month.JUN;
		
		} else if(month.equalsIgnoreCase(Month.JUL.toString())) {
		
			selected = Month.JUL;
		
		} else if(month.equalsIgnoreCase(Month.AUG.toString())) {
		
			selected = Month.AUG;
		
		} else if(month.equalsIgnoreCase(Month.SEP.toString())) {
		
			selected = Month.SEP;
		
		} else if(month.equalsIgnoreCase(Month.OCT.toString())) {
		
			selected = Month.OCT;
		
		} else if(month.equalsIgnoreCase(Month.NOV.toString())) {
		
			selected = Month.NOV;
		
		} else if(month.equalsIgnoreCase(Month.DEC.toString())) {
		
			selected = Month.DEC;
		
		}
		
		return selected;
		
	}
}
```
###### src/notify/TaskType.java
``` java

/**
 * Author: Chua Si Hao
 * Matric No: A0125471L
 * For CS2103T - Notify
 */

package notify;

/**
 * This TaskType enumeration indicates the TaskType that the system supports
 */
public enum TaskType {

	RANGE, DEADLINE, FLOATING

}
```
