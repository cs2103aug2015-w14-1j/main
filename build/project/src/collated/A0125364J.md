# A0125364J
###### src/notify/logic/Logic.java
``` java
package notify.logic;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Iterator;
import java.util.Stack;

import notify.Task;
import notify.TaskType;
import notify.logic.command.Command;
import notify.logic.command.Result;
import notify.logic.command.ReversibleCommand;
import notify.logic.parser.CommandParser;
import notify.storage.api.Storage;

public class Logic {
	
	private CommandParser commandParser;
	private Storage storage;
	private TaskManager taskManager;
	private Stack<ReversibleCommand> history;
	
	public Logic() {
		
		this.storage = new Storage();
		this.history = new Stack<ReversibleCommand>();
		this.taskManager = new TaskManager(this.storage);
		this.commandParser = new CommandParser(this.storage, this.taskManager, this.history);
		
	}
	
	public CommandParser getCommandParser() {
		
		return this.commandParser;
		
	}
	
	public Stack<ReversibleCommand> getHistory(){
		
		return this.history;
	}
	
	/**
	 * Writes the changes into the file.
	 */
	public void save() {
		
		this.storage.saveTasks(taskManager.getTasks());
		
	}
	
	public Storage getStorage() {
		
		return this.storage;
		
	}
	
	public TaskManager getTaskManager() {
		
		return this.taskManager;
		
	}
	
	/**
	 * Process the input entered by the user.
	 * @param input input entered by the user.
	 */
	public Result processCommand(String input) {
		
		Command command = this.commandParser.parse(input);
		Result result = command.execute();
		
		if(command.isPersistable()) {
			
			save();
			
		}
		
		return result;
		
	}
	
	public ArrayList<Task> getTasksOn(Calendar date, boolean isCompleted) {
		
		return taskManager.getTasks(date, isCompleted);
		
	}
	 
	public ArrayList<Task> getDailyTasks(Calendar date, boolean isCompleted) {
		
		Calendar today = Calendar.getInstance();
		
		int todayYear = today.get(Calendar.YEAR);
		int todayDay = today.get(Calendar.DAY_OF_YEAR);
		int dateYear = date.get(Calendar.YEAR);
		int dateDay = date.get(Calendar.DAY_OF_YEAR);
		
		ArrayList<Task> tasks = this.taskManager.getTasks(date, isCompleted);
		
		for(Iterator<Task> iterator = tasks.iterator(); iterator.hasNext(); ) {
			
			Task task = iterator.next();
			
			if(task.getTaskType() == TaskType.RANGE) {
				
				int taskStartYear = task.getStartDate().get(Calendar.YEAR);
				int taskStartDay = task.getStartDate().get(Calendar.DAY_OF_YEAR);
				
				if(task.isStarted()) {

					if(!(todayYear == dateYear && todayDay == dateDay)) {
						
						iterator.remove();
						
					}
					
				} else {
					
					if(!(taskStartYear == dateYear && taskStartDay == dateDay)) {
						
						iterator.remove();
						
					}
					
				}
				
			}
			
		}
		
		return tasks;
		
	}
	
	public ArrayList<Task> getComingSoonTasks() {
		
		return this.taskManager.getComingSoonTasks();
		
	}
	
	public ArrayList<Task> getOverdueTasks() {
		
		return this.taskManager.getOverdueTasks();
		
	}
	
	public ArrayList<Task> getFloatingTasks() {
		
		return this.taskManager.getTasks(TaskType.FLOATING, false);
		
	}
	
	public ArrayList<Task> getCompletedTasks() {
		
		return this.taskManager.getTasks(true);
		
	}

}
```
###### src/notify/logic/Main.java
``` java
package notify.logic;

import java.io.IOException;

import javafx.application.Application;
import javafx.application.Platform;
import javafx.event.EventHandler;
import javafx.fxml.FXMLLoader;
import javafx.scene.Scene;
import javafx.scene.layout.BorderPane;
import javafx.stage.Stage;
import javafx.stage.WindowEvent;
import notify.view.MainViewHandler;

public class Main extends Application {
	private static double MIN_SCREEN_WIDTH = 1100;
	private static double MIN_SCREEN_HEIGHT = 732;
	
	private static String MAIN_VIEW_PATH = "/notify/view/MainView.fxml";
	
	private Logic logic;
	private Stage primaryStage;
	private BorderPane mainView;

	@Override
	public void start(Stage primaryStage) {
		
		this.primaryStage = primaryStage;
		this.primaryStage.setTitle("Notify");
		this.logic = new Logic();
		
		initMainView();
		
	}
	
	public void initMainView() {
		
		try {

			FXMLLoader fxmlLoader = new FXMLLoader();
			fxmlLoader.setLocation(Main.class.getResource(MAIN_VIEW_PATH));

			mainView = (BorderPane)fxmlLoader.load();
			
			Scene scene = new Scene(mainView);
			scene.getStylesheets().add("https://fonts.googleapis.com/css?family=Roboto:400,900italic,900,700italic,700,500italic,500,400italic,300italic,300,100italic,100");
			scene.getStylesheets().add("https://fonts.googleapis.com/css?family=Roboto+Slab:400,100,300,700");
			scene.getStylesheets().add("https://fonts.googleapis.com/css?family=Roboto+Condensed:400,300,300italic,400italic,700,700italic");
			
			primaryStage.setScene(scene);
			primaryStage.setMinHeight(MIN_SCREEN_HEIGHT);
			primaryStage.setMinWidth(MIN_SCREEN_WIDTH);

	        this.primaryStage.setOnCloseRequest(new EventHandler<WindowEvent>() {
	        	
	        	@Override
	            public void handle(WindowEvent event) {
	        		
	                Platform.runLater(new Runnable() {
	                	
	                    @Override
	                    public void run() {
	                    	logic.save();
	                    }
	                    
	                });
	                
	            }
	        	
	        });
	        
			primaryStage.show();
			
			MainViewHandler mainViewHandler = fxmlLoader.getController();
			mainViewHandler.setLogic(logic);
			mainViewHandler.load();
			
		} catch(IOException e) {
			
			e.printStackTrace();
			
		} catch(Exception e) {
			
			System.out.println(e.getMessage());
			e.printStackTrace();
			
		}
		
	}

	public static void main(String[] args) {
		
		launch(args);
		
	}
}
```
###### src/notify/logic/TaskManager.java
``` java
	/**
	 * Retrieve the task that is not deleted with the id specified or null if there are no task with the id specified.
	 * 
	 * @param taskId task id of the task to be retrieved
	 * @param isCompleted true to retrieve only completed tasks, false to retrieve only uncompleted task
	 * @return a task object of the task is found, otherwise return null
	 */
	public Task getTask(int taskId, boolean isCompleted) {

		for (Task task: taskList) {

			if (task.getTaskId() == taskId && !task.isDeleted() && task.isCompleted() == isCompleted) {

				return task;

			}

		}

		return null;

	}

	/**
	 * Retrieve all the tasks (including tasks that are deleted).
	 * 
	 * @return a list of all the tasks
	 */
	public ArrayList<Task> getTasks() {
		
		return taskList;

	}

	/**
	 * Retrieve all the tasks where its task type is equals to the task type specified.
	 * 
	 * @param taskType type of task to retrieve
	 * @param isCompleted true to retrieve only completed tasks, false to retrieve only uncompleted task
	 * @return a list of task where task type is equals to the task type specified.
	 */
	public ArrayList<Task> getTasks(TaskType taskType, boolean isCompleted) {

		ArrayList<Task> tempList = new ArrayList<Task>();

		for (Task task: taskList) {

			if (task.getTaskType() == taskType && !task.isDeleted() && task.isCompleted() == isCompleted) {

				tempList.add(task);

			}

		}

		Collections.sort(tempList);
		return tempList;

	}

	/**
	 * Retrieve all the tasks where its date falls on the date specified or the
	 * date specified is within its range.
	 * 
	 * @param date date of the task to retrieve
	 * @param isCompleted true to retrieve only completed tasks, false to retrieve only uncompleted task
	 * @return a list of task where its date falls on the date specified or the date specified is within its range.
	 */
	public ArrayList<Task> getTasks(Calendar date, boolean isCompleted) {

		ArrayList<Task> tempList = new ArrayList<Task>();

		for (Task task: taskList) {

			if (task.isOn(date) && !task.isDeleted() && task.isCompleted() == isCompleted) {

				tempList.add(task);

			}

		}

		Collections.sort(tempList);
		return tempList;

	}

	/**
	 * Retrieve all the tasks that are not deleted and its completed status
	 * matches the completed status specified.
	 * 
	 * @param isCompleted true to retrieve completed tasks. false to retrieve uncompleted tasks
	 * @return a list of completed task or uncompleted task depending on the value passed in.
	 */
	public ArrayList<Task> getTasks(boolean isCompleted) {

		ArrayList<Task> tempList = new ArrayList<Task>();

		for (Task task: taskList) {

			if (task.isCompleted() == isCompleted && !task.isDeleted()) {

				tempList.add(task);

			}

		}

		Collections.sort(tempList);
		return tempList;
	}

	/**
	 * Retrieve all the tasks that are overdue. 
	 * Overdue tasks are tasks that have its end date earlier than todays date.
	 * 
	 * @return a list of tasks that are overdue
	 */
	public ArrayList<Task> getOverdueTasks() {

		ArrayList<Task> tempList = new ArrayList<Task>();

		for (Task task: taskList) {

			if (task.isOverdue()) {

				assert task.isCompleted() == false;
				assert task.isDeleted() == false;

				tempList.add(task);

			}

		}

		Collections.sort(tempList);
		return tempList;

	}

	/**
	 * Retrieve all the tasks that are coming soon. Coming soon tasks are tasks
	 * that are not within the week (or today and up coming 6 days )
	 * 
	 * @return a list of tasks that are coming soon.
	 */
	public ArrayList<Task> getComingSoonTasks() {

		ArrayList<Task> tempList = new ArrayList<Task>();

		for (Task task: taskList) {

			if (task.isComingSoon()) {

				assert task.isCompleted() == false;
				assert task.isDeleted() == false;

				tempList.add(task);

			}

		}

		Collections.sort(tempList);
		return tempList;

	}
```
###### src/notify/stylesheet/default.css
``` css

.main {
	-fx-background-color:#FFFFFF;
}

.software-title {
	-fx-font-family:'Roboto Black';	
	-fx-font-size:24;
	-fx-font-weight:normal;
}

.overlay {
	-fx-background-color:#000000;
}

.text-field {
	-fx-focus-color:#16A085;
	-fx-font-family:'Roboto';
	-fx-font-size:14;
	-fx-text-box-border:#16A085;
}

.message {
	-fx-font-family:'Roboto Black';
	-fx-font-size:12;
}

.title {
	-fx-font-family:'Roboto Condensed';	
	-fx-font-size:17;
	-fx-font-weight:bold;
}

.subtitle {
	-fx-font-family:'Roboto Condensed';
	-fx-font-size:12;
	-fx-font-weight:bold;
}

.taskname {
	-fx-font-family:'Roboto Slab Regular';	
	-fx-font-size:12;
	/*-fx-font-weight:bold;*/
}

.timestamp {
	-fx-font-family:'Roboto Condensed';
	-fx-font-size:11;
	-fx-font-weight:bold;
}

/**************** overdue styling ****************/
.overdue-scrollpane, .overdue-panel {
	-fx-background-color:rgb(255, 138, 128);
}

.overdue-scrollpane > .scroll-bar:horizontal .thumb,
.overdue-scrollpane > .scroll-bar:vertical .thumb {
	-fx-background-color:#99534D;
}

.overdue-panel .check-box > .box {
	-fx-border-color:#7E443F;
}

.overdue-panel .check-box {
	-fx-font-family:'Roboto';
	-fx-text-fill:#5D322E;
	-fx-font-size:10;
	-fx-font-weight:bold;
}

.overdue-panel .title, .overdue-panel .taskname {
	-fx-text-fill:#5D322E;
}

.overdue-panel .subtitle, .overdue-panel .timestamp {
	-fx-text-fill:#B26059;
}

/**************** floating styling ****************/
.floating-scrollpane, .floating-panel {
	-fx-background-color:rgb(128, 216, 255);
}

.floating-scrollpane > .scroll-bar:horizontal .thumb,
.floating-scrollpane > .scroll-bar:vertical .thumb {
	-fx-background-color:#406C7F;
}

.floating-panel .check-box > .box {
	-fx-border-color:#406C7F;
}

.floating-panel .check-box {
	-fx-font-family:'Roboto';
	-fx-text-fill:#2D4D5A;
	-fx-font-size:10;
	-fx-font-weight:bold;
}

.floating-panel .title, .floating-panel .taskname {
	-fx-text-fill:#2D4D5A;
}

.floating-panel .subtitle, .floating-panel .timestamp {
	-fx-text-fill:#5997B2;
}

/**************** comingsoon styling ****************/
.comingsoon-scrollpane, .comingsoon-panel {
	-fx-background-color:rgb(204, 255, 144);
}

.comingsoon-scrollpane > .scroll-bar:horizontal .thumb,
.comingsoon-scrollpane > .scroll-bar:vertical .thumb {
	-fx-background-color:#657E47;
}

.comingsoon-panel .check-box > .box {
	-fx-border-color:#657E47;
}

.comingsoon-panel .check-box {
	-fx-font-family:'Roboto';
	-fx-text-fill:#485A33;
	-fx-font-size:10;
	-fx-font-weight:bold;
}

.comingsoon-panel .title, .comingsoon-panel .taskname {
	-fx-text-fill:#485A33;
}

.comingsoon-panel .subtitle, .comingsoon-panel .timestamp {
	-fx-text-fill:#8EB264;
}

/**************** daily styling ****************/
.daily-scrollpane, .daily-panel {
	-fx-background-color:rgb(255, 255, 141);
}

.daily-scrollpane > .scroll-bar:horizontal .thumb,
.daily-scrollpane > .scroll-bar:vertical .thumb {
	-fx-background-color:#7E7E45;
}

.daily-panel .check-box > .box {
	-fx-border-color:#7E7E45;
}

.daily-panel .check-box {
	-fx-font-family:'Roboto';
	-fx-text-fill:#5D5D33;
	-fx-font-size:10;
	-fx-font-weight:bold;
}

.daily-panel .title, .daily-panel .taskname {
	-fx-text-fill:#5D5D33;
}

.daily-panel .subtitle, .daily-panel .timestamp {
	-fx-text-fill:#B2B262;
}

/**************** search styling ****************/
.search-view-title {
	-fx-font-family:'Roboto Condensed';
	-fx-font-size:24;
	-fx-font-weight:normal;
}

.search-pane .title {
	-fx-font-family:'Roboto Condensed';
	-fx-font-size:20;
	-fx-font-weight:normal;
}

.search-pane .check-box {
	-fx-font-family:'Roboto';
	-fx-text-fill:#FFFFFF;
	-fx-font-size:10;
	-fx-font-weight:bold;
}

.search-pane .taskname, .search-pane .timestamp {
	-fx-text-fill:#FFFFFF;
}

/**************** completed styling ****************/
.completed-pane .title {
	-fx-font-family:'Roboto Condensed';
	-fx-font-size:24;
	-fx-font-weight:normal;
}

.completed-pane .check-box {
	-fx-font-family:'Roboto';
	-fx-text-fill:#FFFFFF;
	-fx-font-size:10;
	-fx-font-weight:bold;
}

.completed-pane .taskname, .completed-pane .timestamp {
	-fx-text-fill:#FFFFFF;
}

/**************** help styling ****************/
.help-pane .title {
	-fx-font-family:'Roboto Black';
	-fx-font-size:48;
	-fx-font-weight:normal;
}

.help-pane .subtitle {
	-fx-font-family:'Roboto';
	-fx-font-size:13;
	-fx-font-weight:bold;
}





.overlay-scrollpane, .overlay-scrollpane > .viewport {
	-fx-background-color:transparent;
}



.check-box > .box {
	-fx-background-color:transparent;
	-fx-border-color:#FFFFFF;
	-fx-border-radius:3px;
	-fx-border-style:dashed;
}

.scroll-pane > .scroll-bar:horizontal,
.scroll-pane > .scroll-bar:vertical {
	-fx-background-color:transparent;
    -fx-background-radius:2em;
    -fx-border-radius:2em;
}

.scorll-pane > .scroll-bar:horizontal .track,
.scroll-pane > .scroll-bar:vertical .track {
	-fx-background-color:transparent;
    -fx-background-radius:0em;
    -fx-border-color:transparent;
    -fx-border-radius:2em;
}

.scroll-pane > .scroll-bar:horizontal .thumb,
.scroll-pane > .scroll-bar:vertical .thumb {
	-fx-background-insets:4, 5, 6;
    -fx-background-radius:2em;
    -fx-border-radius:2em;
}

.scroll-pane > .scroll-bar > .increment-button, 
.scroll-pane > .scroll-bar > .decrement-button {
    -fx-background-color:transparent; 
    -fx-background-radius:0em;
    -fx-padding:0 0 10 0;
}

.scroll-pane > .scroll-bar > .increment-button > .increment-arrow,
.scroll-pane > .scroll-bar > .decrement-button > .decrement-arrow {
	-fx-shape:" ";
	-fx-padding:0;
}
```
###### src/notify/Task.java
``` java
package notify;

import java.util.Calendar;

public class Task implements Comparable<Task> {

	public static final int UNASSIGNED_TASK = -1;
	
	private static final int DAYS_A_WEEK = 7;

	// This stores the id that is associated with the task
	private int id = UNASSIGNED_TASK;

	// This stores the event name specified for the task
	private String name;

	// This stores the date and time specified for the task
	private DateRange dateRange;

	// This is the category that the task belongs to
	private String category = new String();

	// This stores the state of the event if it has been completed
	private boolean isCompleted = false;

	private boolean isDeleted = false;

	// This stores the task type that it belongs to
	private TaskType taskType;

	public Task(int id, TaskType taskType, String name) {
		this(id, taskType, name, null);
	}

	public Task(int id, TaskType taskType, String name, DateRange dateRange) {
		this(id, taskType, name, dateRange, false);
	}

	public Task(int id, TaskType taskType, String name, DateRange dateRange,
			boolean isCompleted) {

		assert taskType != null;
		assert name != null;
	}
		
	public Task(int id, TaskType taskType, String name, DateRange dateRange, String category, boolean isCompleted) {

		assert taskType != null;
		assert name != null;  

		this.id = id;
		this.taskType = taskType;
		this.name = name;
		this.dateRange = dateRange;
		this.category = category;
		this.isCompleted = isCompleted;
	}

	/**
	 * Returns true if this task is overdue. An overdue task is a deadline task
	 * that has not finished and its end time is earlier than the time when this
	 * method is called.
	 * 
	 * @return true if this task is overdue
	 */
	
	public boolean isOverdue() {
		
		Calendar today = Calendar.getInstance();
		
		int todayYear = today.get(Calendar.YEAR);
		int todayDay = today.get(Calendar.DAY_OF_YEAR);
		int endDateYear, endDateDay;
		
		boolean isOverdue = false;
		
		switch(taskType) {
		
			case FLOATING:
				
				isOverdue = false;
				
				break;
				
			default:
				assert getEndDate() != null;
				
				endDateYear = getEndDate().get(Calendar.YEAR);
				endDateDay = getEndDate().get(Calendar.DAY_OF_YEAR);
				
				if(endDateYear < todayYear && !isCompleted && !isDeleted) {
					
					isOverdue = true;
					
				} else if(endDateYear == todayYear && endDateDay < todayDay && !isCompleted && !isDeleted) {
					
					isOverdue = true;
					
				}
				
				break;
				
		}
		
		return isOverdue;
		
	}
	
	/**
	 * Check whether the task is on the date specified (for deadline tasks)
	 * Check whether the date specified is within the range of date the task (for range tasks)
	 * Includes task that are completed.
	 * @param date day to be checked against 
	 * @return true if the task is on the date specified, or within the range of date of the task. else return false
	 */
	public boolean isOn(Calendar date) {
		
		int dateYear = date.get(Calendar.YEAR);
		int dateDay = date.get(Calendar.DAY_OF_YEAR);
		
		int taskEndYear, taskEndDay, taskStartYear, taskStartDay;
		
		boolean isOnDate = false;
		
		switch(taskType) {
		
			case DEADLINE:

				taskEndYear = getEndDate().get(Calendar.YEAR);
				taskEndDay = getEndDate().get(Calendar.DAY_OF_YEAR);
				
				if(dateYear == taskEndYear && dateDay == taskEndDay && !isDeleted) {
					
					isOnDate = true;
					
				}
				
				break;
				
			case RANGE:

				taskEndYear = getEndDate().get(Calendar.YEAR);
				taskEndDay = getEndDate().get(Calendar.DAY_OF_YEAR);
				taskStartYear = getStartDate().get(Calendar.YEAR);
				taskStartDay = getStartDate().get(Calendar.DAY_OF_YEAR);
				
				if(taskStartYear < dateYear && dateYear < taskEndYear) {
					
					isOnDate = true;
					
				} else if(taskStartYear == dateYear && dateYear < taskEndYear
						&& taskStartDay <= dateDay) {
					
					isOnDate = true;
					
				} else if(taskStartYear < dateYear && dateYear == taskEndYear
						&& dateDay <= taskEndDay) {
					
					isOnDate = true;
					
				} else if(taskStartYear == dateYear && dateYear == taskEndYear
						&& taskStartDay <= dateDay && dateDay <= taskEndDay) {

					isOnDate = true;
					
				}
				
				/*if(taskStartYear <= dateYear && dateYear <= taskEndYear
						&& taskStartDay <= dateDay && dateDay <= taskEndDay && !isDeleted) {
					
					isOnDate = true;
					
				}	*/		
				
				break;
			
			default:
				
				isOnDate = false;
				
				break;
		
		}
		
		return isOnDate;
		
	}
	
	/**
	 * Check whether the task is coming soon.
	 * A coming soon task is a task that will happen after than seven days or more
	 * @return true if the task is a coming soon task, else false
	 */
	public boolean isComingSoon() {
		
		Calendar today = Calendar.getInstance();
		boolean isComingSoon = true;
		
		switch(taskType) {
			
			case FLOATING:
				
				isComingSoon = false;
				
				break;
				
			default:

				for(int i = 0; i < DAYS_A_WEEK; i++) {
					
					if(isOn(today) || isOverdue() || isCompleted || isDeleted) {
						
						isComingSoon = false;
						
						break;
						
					}
					
					today.add(Calendar.DAY_OF_MONTH, 1);
					
				}
				
				break;
		
		}
		
		return isComingSoon;
		
	}
	
	/**
	 * Check whether the ranged task ends within the week .
	 * A ending soon task is a task that will end within seven days.
	 * @return true if the task is a ending soon task, else false
	 */
	public boolean isEndingSoon() {

		Calendar today = Calendar.getInstance();
		boolean isEndingSoon = false;
		
		switch(taskType) {
		
			case RANGE:
				
				int taskEndYear = getEndDate().get(Calendar.YEAR);
				int taskEndDay = getEndDate().get(Calendar.DAY_OF_YEAR);
				
				for(int i = 0; i < DAYS_A_WEEK; i++) {

					int todayYear = today.get(Calendar.YEAR);
					int todayDay = today.get(Calendar.DAY_OF_YEAR);
					
					if(todayYear == taskEndYear && todayDay == taskEndDay && !isCompleted && !isDeleted && !isOverdue()) {
						
						isEndingSoon = true;
						
						break;
						
					}
					
					
					today.add(Calendar.DAY_OF_MONTH, 1);
					
				}
				
				break;
			
			default:
				
				isEndingSoon = false;
				
				break;
		
		}
		
		return isEndingSoon;
		
	}
	
	public boolean isStarted() {

		Calendar today = Calendar.getInstance();
		boolean isStarted = false;
		
		int todayYear = today.get(Calendar.YEAR);
		int todayDay = today.get(Calendar.DAY_OF_YEAR);
		int taskStartYear = getStartDate().get(Calendar.YEAR);
		int taskStartDay = getStartDate().get(Calendar.DAY_OF_YEAR);
		
		switch(taskType) {
		
			case RANGE:
				
				if(!isCompleted && !isDeleted && !isOverdue()) {
					
					isStarted = (taskStartYear < todayYear) || (taskStartYear == todayYear && taskStartDay < todayDay);
					
				}
				
				
				break;
			
			default:
				
				isStarted = false;
				
				break;
		
		}
		
		return isStarted;
	}
	
	public boolean isSearchedTask(String keyWord) {
		boolean result = false;
		
		if(isNull(this.category)) {
			if(String.valueOf(this.id).equals(keyWord) || this.name.toLowerCase().contains(keyWord.toLowerCase()))
				result = true;
		} else {
			if(String.valueOf(this.id).equals(keyWord) || this.name.toLowerCase().contains(keyWord.toLowerCase()) || this.category.toLowerCase().contains(keyWord.toLowerCase())) {
				result = true;
			}
		}
		return result;
	}
	
	private boolean isNull(Object obj) {
		return obj==null;
	}
	
	public int getTaskId() {
		return this.id;
	}

	public void setTaskId(int id) {
		this.id = id;
	}

	public String getTaskName() {
		return this.name;
	}

	public void setTaskName(String name) {
		this.name = name;
	}

	public String getCategory() {
		return this.category;
	}

	public void setCategory(String category) {
		this.category = category;
	}

	public DateRange getDateRange() {
		return this.dateRange;
	}

	public void setDateRange(DateRange dateRange) {
		this.dateRange = dateRange;
	}
	
	public Calendar getStartDate() {
		return this.dateRange.getStartDate();
	}
	
	public Calendar getEndDate() {
		return this.dateRange.getEndDate();
	}
	
	public Calendar getStartTime() {
		return this.dateRange.getStartTime();
	}
	
	public Calendar getEndTime() {
		return this.dateRange.getEndTime();
	}

	public boolean isDeleted() {
		return this.isDeleted;
	}

	public void setDeleted(boolean isDeleted) {
		this.isDeleted = isDeleted;
	}

	public boolean isCompleted() {
		return this.isCompleted;
	}

	public void setCompleted(boolean isCompleted) {
		this.isCompleted = isCompleted;
	}
	
	public void setTaskType(TaskType taskType) {
		this.taskType = taskType;
	}

	public TaskType getTaskType() {
		return this.taskType;
	}
	
	public int compareTo(Task task) {
		
		if(dateRange == null) {
			
			if(task.getDateRange() == null) {
				
				return 0;
				
			} else {
				
				return 1;
				
			}
			
		}
		
		if(task.getDateRange() == null) {
			
			if(dateRange == null) {
				
				return 0;
				
			} else {
				
				return -1;
				
			}
			
		}
		
		Calendar startDate = getStartDate();
		Calendar endDate = getEndDate();
		Calendar taskStartDate = task.getStartDate();
		Calendar taskEndDate = task.getEndDate();
		
		if(startDate != null) {
			
			int startYear = startDate.get(Calendar.YEAR);
			int startDay = startDate.get(Calendar.DAY_OF_YEAR);
			
			if(taskStartDate != null) {
				
				int taskStartYear = taskStartDate.get(Calendar.YEAR);
				int taskStartDay = taskStartDate.get(Calendar.DAY_OF_YEAR);
				
				if(startYear - taskStartYear == 0) {
					
					return startDay - taskStartDay;
					
				} else {
					
					return startYear - taskStartYear;
					
				}
				
			} else if(taskEndDate != null) {
				
				int taskEndYear = taskEndDate.get(Calendar.YEAR);
				int taskEndDay = taskEndDate.get(Calendar.DAY_OF_YEAR);
				
				if(startYear - taskEndYear == 0) {
					
					return startDay - taskEndDay;
					
				} else {
					
					return startYear - taskEndYear;
					
				}
				
			} else {
				
				return -1;
				
			}
			
		} else if(endDate != null) {

			int endYear = endDate.get(Calendar.YEAR);
			int endDay = endDate.get(Calendar.DAY_OF_YEAR);
			
			if(taskStartDate != null) {
				
				int taskStartYear = taskStartDate.get(Calendar.YEAR);
				int taskStartDay = taskStartDate.get(Calendar.DAY_OF_YEAR);
				
				if(endYear - taskStartYear == 0) {
					
					return endDay - taskStartDay;
					
				} else {
					
					return endYear - taskStartYear;
					
				}
				
			} else if(taskEndDate != null) {
				
				int taskEndYear = taskEndDate.get(Calendar.YEAR);
				int taskEndDay = taskEndDate.get(Calendar.DAY_OF_YEAR);
				
				if(endYear - taskEndYear == 0) {
					
					return endDay - taskEndDay;
					
				} else {
					
					return endYear - taskEndYear;
					
				}
				
			} else {
				
				return -1;
			
			}
			
		} else {
			
			if(taskStartDate != null || taskEndDate != null) {
				
				return 1;
				
			} else {
				
				return 0;
				
			}
			
		}
		
	}

	public String toString() {
		return name + " " + category;
	}
}
```
###### src/notify/view/MainViewHandler.java
``` java
package notify.view;

import notify.Task;
import notify.TaskType;
import notify.logic.*;
import notify.logic.command.Action;
import notify.logic.command.Result;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Stack;


import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.CheckBox;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyCodeCombination;
import javafx.scene.input.KeyCombination;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.FlowPane;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Paint;
import javafx.scene.text.Font;
import javafx.scene.text.FontPosture;
import javafx.scene.text.FontWeight;

public class MainViewHandler {
	
	private static String[] DAYS_OF_WEEK = { "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" };	
	
	// styling for container containing each line of item
	private static double HBOX_NODE_SPACING = 3.5;
	private static Pos HBOX_NODE_ALIGNMENT = Pos.TOP_LEFT;
	private static Insets HEADER_PADDING = new Insets(0, 0, 2, 0);	//top, right, bottom, left
	
	// font color for different type of task
	private static Paint ERROR_MESSAGE_FILL = Paint.valueOf("#CC181E");
	private static Paint FEEDBACK_MESSAGE_FILL = Paint.valueOf("#16A085");
	
	// String for the css class names
	private static String TITLE_CSS_CLASS = "title";
	private static String SUBTITLE_CSS_CLASS = "subtitle";
	private static String TASK_NAME_CSS_CLASS = "taskname";
	private static String TIMESTAMP_CSS_CLASS = "timestamp";
	
	// String pattern for dates
	private static String SHORT_DAY_PATTERN = "EEE";
	private static String LONG_DAY_PATTERN = "EEEE";
	private static String SHORT_DATE_PATTERN = "dd MMM yy";
	private static String LONG_DATE_PATTERN = "dd MMMM yy";
	private static String TIME_PATTERN = "hh:mm a";
	
	// String format for deadline tasks timestamp
	private static String DEADLINE_DATE_START_END_TIME_TIMESTAMP_FORMAT = "%1$s, %2$s to %3$s";
	private static String DEADLINE_DATE_END_TIME_TIMESTAMP_FORMAT = "%1$s, %2$s";
	private static String DEADLINE_END_DATE_TIMESTAMP_FORMAT = "%1$s";
	private static String DEADLINE_FROM_START_TO_END_TIME_TIMESTAMP_FORMAT = "from %1$s to %2$s";
	private static String DEADLINE_AT_END_TIME_TIMESTAMP_FORMAT = "at %1$s";
	
	// String format for ranged tasks timestamp
	private static String RANGE_START_DATE_TIME_TO_END_DATE_TIME_TIMESTAMP_FORMAT = "%1$s, %2$s to %3$s, %4$s";
	private static String RANGE_START_DATE_TO_END_DATE_TIMESTAMP_FORMAT = "%1$s to %2$s";
	private static String RANGE_FROM_START_TIME_TILL_END_DATE_TIME_TIMESTAMP_FORMAT = "from %1$s till %2$s, %3$s";
	private static String RANGE_TILL_END_DATE_TIME_TIMESTAMP_FORMAT = "till %1$s, %2$s";
	private static String RANGE_TILL_END_DATE_TIMESTAMP_FORMAT = "till %1$s";
	
	// String format for title timestamp
	private static String LONG_DAY_DATE_FORMAT = "%1$s, %2$s";
	
	// String for title of different tasks status
	private static String OVERDUE_TITLE = "Overdue";
	private static String FLOATING_TITLE = "Floating";
	private static String COMING_TITLE = "Coming Soon...";
	private static String TODAY_TITLE = "Today";
	private static String TOMORROW_TITLE = "Tomorrow";
	
	// String for feedback / error messages
	private static String INVALID_COMMAND_MESSAGE = "Invalid command '%1$s'. Please try again.";
	private static String ADDED_MESSAGE = "Task added: '%1$s. %2$s'";
	private static String ADD_FAIL_MESSAGE = "Failed to add task";
	private static String DELETED_MESSAGE = "Task '%1$s. %2$s' deleted";
	private static String DELETE_FAIL_MESSAGE = "Failed to delete task";
	private static String EDITED_MESSAGE = "Task '%1$s. %2$s' edited";
	private static String EDIT_FAIL_MESSAGE = "Failed to edit task";
	private static String MARKED_MESSAGE = "Task: '%1$s. %2$s' marked as completed";
	private static String MARK_FAIL_MESSAGE = "Failed to mark task";
	private static String SET_MESSAGE = "Path successfully changed to: '%1$s'";
	private static String SET_FAIL_MESSAGE = "Fail to change path to: '%1$s'";
	private static String SEARCH_RESULT_MESSAGE = "Search Result for '%1$s':";
	
	private static String LATEST_SEARCH_TERM = "";
	
	private static String SEARCH_COMMAND = "search %1$s";
	private static String MARK_COMMAND = "mark %1$s";
	private static String UNDO_COMMAND = "undo";
	
	private static int EXIT_STATUS = 0;
	
	// stack to store commands history
	private static Stack<String> COMMAND_HISTORY_STACK = new Stack<String>();
	private static Stack<String> COMMAND_FUTURE_STACK = new Stack<String>();
	
	private Logic logic;
	
	// arraylist of different types of tasks
	private ArrayList<Task> overdueTasks;
	private ArrayList<Task> floatingTasks;
	private ArrayList<Task> comingTasks;
	private ArrayList<Task> completedTasks;
	private ArrayList<ArrayList<Task>> dailyTasksList;
	
	// fxml controls
	@FXML private VBox vboxFloating;
	@FXML private VBox vboxOverdue;
	@FXML private VBox vboxComing;
	@FXML private VBox vboxOne;
	@FXML private VBox vboxTwo;
	@FXML private VBox vboxThree;
	@FXML private VBox vboxFour;
	@FXML private VBox vboxFive;
	@FXML private VBox vboxSix;
	@FXML private VBox vboxSeven;
	@FXML private VBox vboxSearchCompleted;
	@FXML private VBox vboxSearchUncompleted;
	@FXML private VBox vboxCompletedTask;
	
	@FXML private TextField txtCommand;
	@FXML private Label lblFeedback;
	
	@FXML private Pane pnOverlay;
	@FXML private BorderPane bpnSearch;
	@FXML private BorderPane bpnCompleted;
	@FXML private GridPane gpnHelp;
	@FXML private Label lblSearchTitle;
	
	@FXML
	public void initialize() {
		
	}
	
	/**
	 * Setter for logic.
	 * 
	 * @param logic the logic object created in the Main class.
	 */
	public void setLogic(Logic logic) {
		
		this.logic = logic;
		
	}
	
	/**
	 * Loads the component of the UI
	 */
	public void load() {
		
		txtCommand.requestFocus();
		
		loadOverdueTask();
		loadFloatingTask();
		loadComingTask();
		loadDailyTask();
		
	}
	
	/**
	 * Method to query whether the search view is visible.
	 * 
	 * @return true if the search view is on, otherwise false.
	 */
	public boolean isSearchViewVisible() {
		
		return bpnSearch.isVisible();
		
	}
	
	
	/**
	 * Method to query whether the completed view is visible.
	 * 
	 * @return true if the completed view is on, otherwise false.
	 */
	public boolean isCompletedViewVisible() {
		
		return bpnCompleted.isVisible();
		
	}
	
	/**
	 * Method to query whether the help view is visible.
	 * 
	 * @return true if the help view is on, otherwise false.
	 */
	public boolean isHelpViewVisible() {
		
		return gpnHelp.isVisible();
		
	}
	
	/**
	 * Loads the tasks that are overdue.
	 */
	public void loadOverdueTask() {
		
		overdueTasks = logic.getOverdueTasks();

		HBox header = generateHeader(OVERDUE_TITLE);
		ArrayList<HBox> items = generateList(overdueTasks, false);
		
		vboxOverdue.getChildren().clear();
		vboxOverdue.getChildren().add(header);
		vboxOverdue.getChildren().addAll(items);
		
	}
	
	/**
	 * Loads the tasks that does not have any dates (floating tasks).
	 */
	public void loadFloatingTask() {
		
		floatingTasks = logic.getFloatingTasks();
		
		HBox header = generateHeader(FLOATING_TITLE);
		ArrayList<HBox> items = generateList(floatingTasks, false);
		
		vboxFloating.getChildren().clear();
		vboxFloating.getChildren().add(header);
		vboxFloating.getChildren().addAll(items);
		
	}
	
	/**
	 * Loads the upcoming tasks (tasks that have dates more than 1 week from current date).
	 */
	public void loadComingTask() {
		
		comingTasks = logic.getComingSoonTasks();

		HBox header = generateHeader(COMING_TITLE);
		ArrayList<HBox> items = generateList(comingTasks, false);
		
		vboxComing.getChildren().clear();
		vboxComing.getChildren().add(header);
		vboxComing.getChildren().addAll(items);
		
	}
	
	/**
	 * Loads the tasks that are within the week (current date and 6 days ahead).
	 */
	public void loadDailyTask() {
		
		VBox[] vboxes = { vboxOne, vboxTwo, vboxThree, vboxFour, vboxFive, vboxSix, vboxSeven };
		Calendar calendar = Calendar.getInstance();
		
		dailyTasksList = new ArrayList<ArrayList<Task>>();
		
		for (int i = 0; i < DAYS_OF_WEEK.length; i++) {
			
			ArrayList<Task> dailyTasks = logic.getDailyTasks(calendar, false);
			
			HBox header = generateHeader(calendar);
			ArrayList<HBox> items = generateList(dailyTasks, false);
			
			vboxes[i].getChildren().clear();
			vboxes[i].getChildren().add(header);
			vboxes[i].getChildren().addAll(items);
			
			dailyTasksList.add(dailyTasks);		
			calendar.add(Calendar.DAY_OF_MONTH, 1);
			
		}
		
	}
	
	/**
	 * Loads the search results and display them correctly.
	 * 
	 * @param searchResults the search results
	 */
	public void loadSearchResult(ArrayList<Task> searchResults) {
		
		ArrayList<Task> completedTasks = new ArrayList<Task>();
		ArrayList<Task> uncompletedTasks = new ArrayList<Task>();
		
		completedTasks = filterTask(searchResults, true);
		uncompletedTasks = filterTask(searchResults, false);

		ArrayList<HBox> hboxesCompleted = generateList(completedTasks, true);
		ArrayList<HBox> hboxesUncompleted = generateList(uncompletedTasks, true);
		
		vboxSearchCompleted.getChildren().clear();
		vboxSearchCompleted.getChildren().addAll(hboxesCompleted);
		
		vboxSearchUncompleted.getChildren().clear();
		vboxSearchUncompleted.getChildren().addAll(hboxesUncompleted);
		
	}
	
	/**
	 * Loads the list of completed tasks and display.
	 */
	public void loadCompletedTasks() {
		
		completedTasks = logic.getCompletedTasks();
		
		ArrayList<HBox> hboxes = generateList(completedTasks, true);
		
		vboxCompletedTask.getChildren().clear();
		vboxCompletedTask.getChildren().addAll(hboxes);
		
	}
	
	/**
	 * Make the search view visible.
	 * 
	 * @param searchTerm the search input that was entered by the user.
	 */
	public void showSearchView(String searchTerm) {
		
		lblSearchTitle.setText(String.format(SEARCH_RESULT_MESSAGE, searchTerm));
		
		hideCompletedView();
		hideHelpView();
		
		pnOverlay.setVisible(true);
		bpnSearch.setVisible(true);
		
	}
	
	/**
	 * Make the completed view visible.
	 */
	public void showCompletedView() {
		
		hideSearchView();
		hideHelpView();
		
		pnOverlay.setVisible(true);
		bpnCompleted.setVisible(true);
		
	}
	
	/**
	 * Make the help view visible.
	 */
	public void showHelpView() {
		
		hideSearchView();
		hideCompletedView();
		
		pnOverlay.setVisible(true);
		gpnHelp.setVisible(true);
		
	}
	
	/**
	 * Hide the search view.
	 */
	public void hideSearchView() {
		
		pnOverlay.setVisible(false);
		bpnSearch.setVisible(false);
		
	}
	
	/**
	 * Hide the completed view.
	 */
	public void hideCompletedView() {
		
		pnOverlay.setVisible(false);
		bpnCompleted.setVisible(false);
		
	}
	
	/**
	 * Hide the help view.
	 */
	public void hideHelpView() {
		
		pnOverlay.setVisible(false);
		gpnHelp.setVisible(false);
		
	}
	
	/**
	 * Filter the tasks given according to completed or uncompleted tasks.
	 * 
	 * @param tasks list of tasks that contains completed and uncompleted tasks
	 * @param isCompleted true to retrieve completed tasks from the list, otherwise, false.
	 * 
	 * @return return a list of completed or uncompleted tasks
	 */
	public ArrayList<Task> filterTask(ArrayList<Task> tasks, boolean isCompleted) {
		
		ArrayList<Task> results = new ArrayList<Task>();
		
		for (Task task: tasks) {
			
			if (task.isCompleted() == isCompleted) {
				
				results.add(task);
				
			}
			
		}
		
		return results;
		
	}
	
	/**
	 * Generates the header (without subtitle)
	 * 
	 * @param title the title of the header
	 * @param titleTextFill the font color of the title
	 * 
	 * @return a HBox object (which contains the title)
	 */
	public HBox generateHeader(String title) {
		
		Label lblTitle = createLabel(title, TITLE_CSS_CLASS);
		HBox hbox = createItem(HEADER_PADDING, false, false, lblTitle);
		
		return hbox;
		
	}

	/**
	 * Generates the header by providing the date of the header
	 * 
	 * @param calendar the date of the header to be generated
	 * @param titleTextFill the font color of the title
	 * @param subtitleTextFill the font color of the subtitle
	 * 
	 * @return a HBox object (which contains the title and subtitle)
	 */
	public HBox generateHeader(Calendar calendar) {
		
		Calendar today = Calendar.getInstance();
		Calendar tomorrow = Calendar.getInstance();
		tomorrow.add(Calendar.DAY_OF_MONTH, 1);
		
		SimpleDateFormat dayFormatter = new SimpleDateFormat(LONG_DAY_PATTERN);
		SimpleDateFormat dateFormatter = new SimpleDateFormat(LONG_DATE_PATTERN);
		
		String title = dayFormatter.format(calendar.getTime());
		String subtitle = dateFormatter.format(calendar.getTime());
		
		if (calendar.get(Calendar.DAY_OF_MONTH) == today.get(Calendar.DAY_OF_MONTH)) {
			
			subtitle = String.format(LONG_DAY_DATE_FORMAT, title, subtitle);
			title = TODAY_TITLE; 
			
		} else if (calendar.get(Calendar.DAY_OF_MONTH) == tomorrow.get(Calendar.DAY_OF_MONTH)) {

			subtitle = String.format(LONG_DAY_DATE_FORMAT, title, subtitle);
			title = TOMORROW_TITLE;
			
		}
		
		Label lblTitle = createLabel(title, TITLE_CSS_CLASS);
		Label lblSubtitle = createLabel(subtitle, SUBTITLE_CSS_CLASS);
		HBox hbox = createItem(HEADER_PADDING, false, false, lblTitle, lblSubtitle);
		
		return hbox;
		
	}
	
	/**
	 * Generates the timestamp for all tasks with time.
	 * 
	 * @param task the task to have its timestamp generated
	 * 
	 * @return timestamp (e.g. (23 Oct 15, 02:00PM)
	 */
	public String generateTimeStamp(Task task, boolean isSearch) {
		
		TaskType taskType = task.getTaskType();
		String timeStamp = "";
		
		switch (taskType) {
		
			case DEADLINE:

				timeStamp = generateDeadlineTimestamp(task, isSearch);
				
				break;
				
			case RANGE:
				
				timeStamp = generateRangeTimestamp(task, isSearch);		
				
				break;
				
			default:
				
				timeStamp = "";
				
				break;
		
		}
		
		return timeStamp;
		
	}
	
	
	
	/**
	 * Generates the timestamp for deadline tasks
	 * 
	 * @param task the task to have its timestamp generated
	 * 
	 * @return timestamp (e.g. 23 Oct 15, 02:00PM)
	 */
	public String generateDeadlineTimestamp(Task task, boolean isSearch) {
		
		SimpleDateFormat dateFormatter = new SimpleDateFormat(SHORT_DATE_PATTERN);
		SimpleDateFormat timeFormatter = new SimpleDateFormat(TIME_PATTERN);
		
		Calendar taskEndDate = task.getEndDate();
		Calendar taskStartTime = task.getStartTime();
		Calendar taskEndTime = task.getEndTime();
		
		String taskEndDateStamp = "";
		String taskStartTimeStamp = "";
		String taskEndTimeStamp = "";
		String timestamp = "";

		taskEndDateStamp = dateFormatter.format(taskEndDate.getTime());
		
		if (task.isComingSoon() || task.isOverdue() || isSearch) {

			if (taskStartTime != null) {

				taskStartTimeStamp = timeFormatter.format(taskStartTime.getTime());
				taskEndTimeStamp = timeFormatter.format(taskEndTime.getTime());
				timestamp = String.format(DEADLINE_DATE_START_END_TIME_TIMESTAMP_FORMAT, taskEndDateStamp, taskStartTimeStamp, taskEndTimeStamp);
				
			} else if (taskEndTime != null) {

				taskEndTimeStamp = timeFormatter.format(taskEndTime.getTime());
				timestamp = String.format(DEADLINE_DATE_END_TIME_TIMESTAMP_FORMAT, taskEndDateStamp, taskEndTimeStamp);
				
			} else {
				
				timestamp = String.format(DEADLINE_END_DATE_TIMESTAMP_FORMAT, taskEndDateStamp);
				
			}
			
		} else {
		
			if (taskStartTime != null) {
				
				taskStartTimeStamp = timeFormatter.format(taskStartTime.getTime());
				taskEndTimeStamp = timeFormatter.format(taskEndTime.getTime());
				timestamp = String.format(DEADLINE_FROM_START_TO_END_TIME_TIMESTAMP_FORMAT, taskStartTimeStamp, taskEndTimeStamp);
				
			} else if (taskEndTime != null) {
				
				taskEndTimeStamp = timeFormatter.format(taskEndTime.getTime());
				timestamp = String.format(DEADLINE_AT_END_TIME_TIMESTAMP_FORMAT, taskEndTimeStamp);
				
			}
			
		}

		return timestamp;
		
	}
	
	/**
	 * Generates the timestamp for ranged tasks
	 * 
	 * @param task the task to have its timestamp generated
	 * 
	 * @return timestamp (e.g. 23 Oct 15, 12:00AM to 12:00PM)
	 */
	public String generateRangeTimestamp(Task task, boolean isSearch) {
		
		SimpleDateFormat dateFormatter = new SimpleDateFormat(SHORT_DATE_PATTERN);
		SimpleDateFormat timeFormatter = new SimpleDateFormat(TIME_PATTERN);
		
		Calendar taskStartDate = task.getStartDate();
		Calendar taskStartTime = task.getStartTime();
		Calendar taskEndDate = task.getEndDate();
		Calendar taskEndTime = task.getEndTime();
		
		String taskStartDateStamp = "";
		String taskStartTimeStamp = "";
		String taskEndDateStamp = "";
		String taskEndTimeStamp = "";
		String timeStamp = "";
		
		if (task.isComingSoon() || task.isOverdue() || isSearch) {
			
			if (taskStartTime != null && taskEndTime != null) {
				
				taskStartDateStamp = dateFormatter.format(taskStartDate.getTime());
				taskStartTimeStamp = timeFormatter.format(taskStartTime.getTime());
				taskEndDateStamp = dateFormatter.format(taskEndDate.getTime());
				taskEndTimeStamp = timeFormatter.format(taskEndTime.getTime());
				
				timeStamp = String.format(RANGE_START_DATE_TIME_TO_END_DATE_TIME_TIMESTAMP_FORMAT, taskStartDateStamp, taskStartTimeStamp, taskEndDateStamp, taskEndTimeStamp);
				
			} else {
				
				taskStartDateStamp = dateFormatter.format(taskStartDate.getTime());
				taskEndDateStamp = dateFormatter.format(taskEndDate.getTime());
				
				timeStamp = String.format(RANGE_START_DATE_TO_END_DATE_TIMESTAMP_FORMAT, taskStartDateStamp, taskEndDateStamp);
				
			}
			
		} else {
			
			if (task.isEndingSoon()) {
				
				dateFormatter = new SimpleDateFormat(SHORT_DAY_PATTERN);
				
			} else {
				
				dateFormatter = new SimpleDateFormat(SHORT_DATE_PATTERN);
				
			}
			
			taskEndDateStamp = dateFormatter.format(taskEndDate.getTime());
			
			if (taskStartTime != null && taskEndTime != null) {
				
				taskStartTimeStamp = timeFormatter.format(taskStartTime.getTime());
				taskEndTimeStamp = timeFormatter.format(taskEndTime.getTime());
				
				if (task.isStarted()) {
					
					timeStamp = String.format(RANGE_TILL_END_DATE_TIME_TIMESTAMP_FORMAT, taskEndDateStamp, taskEndTimeStamp);
					
				} else {
					
					timeStamp = String.format(RANGE_FROM_START_TIME_TILL_END_DATE_TIME_TIMESTAMP_FORMAT, taskStartTimeStamp, taskEndDateStamp, taskEndTimeStamp);
					
				}
				
			} else {
				
				timeStamp = String.format(RANGE_TILL_END_DATE_TIMESTAMP_FORMAT, taskEndDateStamp);
				
			}
			
		}
		
		return timeStamp;
		
	}
	
	/**
	 * Generates the items in each list.
	 * 
	 * @param tasks a list
	 * @param isSearch to determine if its generated for the search view
	 * 
	 * @return a list of HBox objects (each HBox object contains the information of a task)
	 */
	public ArrayList<HBox> generateList(ArrayList<Task> tasks, boolean isSearch) {
		
		ArrayList<HBox> hboxes = new ArrayList<HBox>();
		String subtext = "";
		
		for (int i = 0; i < tasks.size(); i++) {
			
			Task task = tasks.get(i);
			
			CheckBox checkBox = createCheckbox(task.getTaskId() + "", task.isCompleted());
			Label lblTaskName = createLabel(task.getTaskName(), TASK_NAME_CSS_CLASS);
			Label lblTaskTime;
			HBox hbox;
			
			switch (task.getTaskType()) {
			
				case FLOATING:
					
					hbox = createItem(true, isSearch, checkBox, lblTaskName);
					
					break;
				
				default:
					
					subtext = generateTimeStamp(task, isSearch);
					lblTaskTime = createLabel(subtext, TIMESTAMP_CSS_CLASS);
					hbox = createItem(true, isSearch, checkBox, lblTaskName, lblTaskTime);
					
					break;
			
			}

			hboxes.add(hbox);
			
		}
		
		return hboxes;
		
	}
	
	/**
	 * Creates the HBox with nodes.
	 * 
	 * @param isSearch to determine if its generated for the search view
	 * @param nodes the nodes to be added to the hbox (labels, checkboxes, etc.)
	 * @return the HBox which represents a single line of item to be added into the VBox
	 */
	public HBox createItem(boolean hasCheckbox, boolean isSearch, Node... nodes) {
		
		HBox hbox = new HBox();
		hbox.setSpacing(HBOX_NODE_SPACING);
		hbox.setAlignment(HBOX_NODE_ALIGNMENT);

		int startIndex = 0;
		if (hasCheckbox) {
			
			hbox.getChildren().add(nodes[startIndex]);
			startIndex = 1;
			
		}

		if (isSearch) {
			
			VBox vbox = new VBox();
			
			for (int i = startIndex; i< nodes.length; i++) {
				
				vbox.getChildren().add(nodes[i]);
				
			}
			
			hbox.getChildren().add(vbox);
			
		} else {
			
			FlowPane flowPane = new FlowPane();
			flowPane.setHgap(HBOX_NODE_SPACING);
			
			for (int i = startIndex; i < nodes.length; i++) {
				
				flowPane.getChildren().add(nodes[i]);
				
			}
			
			hbox.getChildren().add(flowPane);
			
		}
		
		
		return hbox;
		
	}
	
	/**
	 * Overloading method for createItem which allows more specifications.
	 * 
	 * @param insets padding setting around the item
	 * @param hasCheckbox indicate whether a checkbox is needed
	 * @param isSearch indicate whether its a search
	 * @param nodes the nodes to be added to the hbox (labels, checkboxes, etc.)
	 * @return the HBox which represents a single line of item to be added into the VBox
	 */
	public HBox createItem(Insets insets, boolean hasCheckbox, boolean isSearch, Node... nodes) {
		
		HBox hbox = createItem(hasCheckbox, isSearch, nodes);
		hbox.setPadding(insets);
		
		return hbox;
		
	}
	
	/**
	 * Create a label with its formatting.
	 * 
	 * @param text the text to be displayed on the label
	 * @param cssClass css class that the label belongs to
	 * @return a label which contains the text and formatting (default text color)
	 */
	public Label createLabel(String text, String cssClass) {
		
		Label label = new Label(text);
		label.getStyleClass().add(cssClass);
		
		return label;
		
	}
	
	/**
	 * Create a checkbox with its formatting.
	 * 
	 * @param text the text to be displayed on the checkbox
	 * @param isChecked to indicate whether the checkbox is checked or not
	 * @return a checkbox with the settings specified
	 */
	public CheckBox createCheckbox(String text, boolean isChecked) {
		
		CheckBox checkbox = new CheckBox(text);
		checkbox.setSelected(isChecked);
		checkbox.setDisable(isChecked);
		checkbox.setFocusTraversable(false);

		checkbox.setOnAction(event -> checkboxEventHandler(event, checkbox));

		return checkbox;
		
	}
	
	/**
	 * Adds to the command history.
	 * 
	 * @param userInput command entered by the user
	 */
	public void addCommandHistory(String userInput) {

		if (!COMMAND_FUTURE_STACK.isEmpty()) {
			
			COMMAND_HISTORY_STACK.push(userInput);
			
		}
		
		while(!COMMAND_FUTURE_STACK.isEmpty()) {
			
			COMMAND_HISTORY_STACK.push(COMMAND_FUTURE_STACK.pop());
			
		}

		COMMAND_HISTORY_STACK.push(userInput);
		
	}
	
	
	public void setFeedbackLabel(String message, Paint textFill) {
		
		lblFeedback.setText(message);
		lblFeedback.setTextFill(textFill);
		
	}
	
	/**
	 * Refreshes the search view.
	 */
	public void refreshSearchView() {

		if (isSearchViewVisible()) {
			
			String seacrhCommand = String.format(SEARCH_COMMAND, LATEST_SEARCH_TERM);
			
			Result searchResult = logic.processCommand(seacrhCommand);
			loadSearchResult(searchResult.getResults());
			
		}
		
	}
	
	/**
	 * Refreshes the completed view.
	 */
	public void refreshCompletedView() {
		
		if (isCompletedViewVisible()) {
			
			loadCompletedTasks();
			
		}
		
	}
	
	/**
	 * Processes the result after the command is being executed.
	 * 
	 * @param result returned after a command is being executed
	 * @param userInput the input entered by the user
	 */
	public void processResult(Result result, String userInput) {
		
		Action actionPerformed = result.getActionPerformed();
		String feedback = "";
		
		switch (actionPerformed) {
		
			case ADD:
				
				display(ADDED_MESSAGE, ADD_FAIL_MESSAGE, result);
				
				break;
				
			case DELETE:

				display(DELETED_MESSAGE, DELETE_FAIL_MESSAGE, result);
				
				break;
				
			case EDIT:

				display(EDITED_MESSAGE, EDIT_FAIL_MESSAGE, result);
				
				break;
			
			case MARK:

				display(MARKED_MESSAGE, MARK_FAIL_MESSAGE, result);
				
				break;
			
			case UNDO:
				
				refreshSearchView();
				refreshCompletedView();
				load();
				
				break;
			
			case SET:
				
				String path = userInput.toLowerCase().replaceFirst("set", "").trim();
				feedback = String.format(SET_MESSAGE, path);
				
				if (result.isSuccess()) {

					feedback = String.format(SET_MESSAGE, path);
					setFeedbackLabel(feedback, FEEDBACK_MESSAGE_FILL);
					
				} else {

					feedback = String.format(SET_FAIL_MESSAGE, path);
					setFeedbackLabel(feedback, ERROR_MESSAGE_FILL);
					
				}
				
				break;
			
			case SEARCH:
				
				LATEST_SEARCH_TERM = userInput.toLowerCase().replaceFirst("search", "").trim();
				
				loadSearchResult(result.getResults());
				showSearchView(LATEST_SEARCH_TERM);
				setFeedbackLabel("", FEEDBACK_MESSAGE_FILL);
				
				break;
			
			case DISPLAY:
				
				loadCompletedTasks();
				showCompletedView();
				setFeedbackLabel("", FEEDBACK_MESSAGE_FILL);
				
				break;
			
			case HELP:
				
				showHelpView();
				
				break;
			
			case BACK:
				
				hideSearchView();
				hideHelpView();
				hideCompletedView();
				
				break;
				
			case EXIT:
				
				System.exit(EXIT_STATUS);
				
				break;
				
			case INVALID:

				feedback = String.format(INVALID_COMMAND_MESSAGE, userInput);
				
				setFeedbackLabel(feedback, ERROR_MESSAGE_FILL);
				
				break;
		
		}
		
	}
	
	/**
	 * Displays the relevant result after the execution of the commands
	 * 
	 * @param successMessage message to display if the execution has succeeded
	 * @param failMessage message to display if the execution has failed
	 * @param result the result object after executing the command
	 */
	public void display(String successMessage, String failMessage, Result result) {
		
		Task task = result.getFirstResult();
		String feedback = String.format(successMessage, task.getTaskId(), task.getTaskName());
		
		refreshSearchView();
		refreshCompletedView();
		
		if (result.isSuccess()) {

			setFeedbackLabel(feedback, FEEDBACK_MESSAGE_FILL);
			
		} else {

			setFeedbackLabel(failMessage, ERROR_MESSAGE_FILL);
			
		}
		
		load();
		
	}
	
	/**
	 * Event handler for checkbox.
	 * 
	 * @param event event received
	 * @param checkbox the corresponding checkbox that triggered the event
	 */
	public void checkboxEventHandler(ActionEvent event, CheckBox checkbox) {
		
		if (checkbox.isSelected()) {
			
			String userInput = String.format(MARK_COMMAND, checkbox.getText());
			Result result = logic.processCommand(userInput);
			
			processResult(result, userInput);
			
		}
		
	}
	
	/**
	 * Key pressed handler for text box.
	 * 
	 * @param keyEvent key event for the button that is being pressed.
	 */
	public void txtCommandOnKeyPressedHandler(KeyEvent keyEvent) {
		
		String userInput = txtCommand.getText().trim();
		
		try {

			KeyCode keyCode = keyEvent.getCode();

			if (keyCode == KeyCode.ENTER && !userInput.equals("")) {
				
				processEnter(userInput);
				
			} else if (keyCode == KeyCode.BACK_SPACE) {
				
				processBackspace(userInput);
				
			} else if (keyCode == KeyCode.UP) {

				processUp(userInput);
				
			} else if (keyCode == KeyCode.DOWN) {
				
				processDown(userInput);
				
			} else {

				KeyCombination keyCombination = new KeyCodeCombination(KeyCode.Z, KeyCombination.META_DOWN);
				
				if (keyCombination.match(keyEvent)) {
					
					Result result = logic.processCommand(UNDO_COMMAND);
					
					processResult(result, UNDO_COMMAND);
					
				}
				
			}
			
		} catch (IllegalArgumentException e) {
			setFeedbackLabel(String.format(INVALID_COMMAND_MESSAGE, userInput), ERROR_MESSAGE_FILL);
			txtCommand.setText("");

			addCommandHistory(userInput);
			
		} catch (Exception e) {
			
			e.printStackTrace();
			txtCommand.setText("");
			
		}
		
	}
	
	/**
	 * Process the event that occurs after the user presses the enter button.
	 * 
	 * @param userInput the command keyed in by the user.
	 */
	public void processEnter(String userInput) {
		
		Result result = logic.processCommand(userInput);
		processResult(result, userInput);
		
		addCommandHistory(userInput);

		txtCommand.setText("");
		
	}
	
	/**
	 * Process the event that occurs after the user presses the backspace button.
	 * 
	 * @param userInput the command keyed in by the user.
	 */
	public void processBackspace(String userInput) {

		if (userInput.equals("") && isSearchViewVisible()) {
			
			hideSearchView();
			
		} else if (userInput.equals("") && isHelpViewVisible()) {
			
			hideHelpView();
			
		} else if (userInput.equals("") && isCompletedViewVisible()) {
			
			hideCompletedView();
			
		}
		
	}
	
	/**
	 * Process the event that occurs after the user presses the up button.
	 * 
	 * @param userInput the command keyed in by the user.
	 */
	public void processUp(String userInput) {

		if (!COMMAND_HISTORY_STACK.isEmpty()) {
			
			String previousCommand = COMMAND_HISTORY_STACK.pop();
			
			if (!userInput.equals("")) {
				
				COMMAND_FUTURE_STACK.push(userInput);
				
			}
			
			txtCommand.setText(previousCommand);
			
		}
		
		txtCommand.positionCaret(txtCommand.getText().length());
		
	}
	
	/**
	 * Process the event that occurs after the user presses the down button.
	 * 
	 * @param userInput the command keyed in by the user.
	 */
	public void processDown(String userInput) {
		
		if (!COMMAND_FUTURE_STACK.isEmpty()) {
			
			String nextCommand = COMMAND_FUTURE_STACK.pop();
			
			COMMAND_HISTORY_STACK.push(userInput);
			txtCommand.setText(nextCommand);
			
		} else if (!userInput.equals("")) {
			
			COMMAND_HISTORY_STACK.push(userInput);
			txtCommand.setText("");
			
		}
		
		txtCommand.positionCaret(txtCommand.getText().length());
		
	}
	
}
```
